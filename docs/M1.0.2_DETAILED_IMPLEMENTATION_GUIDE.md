# M1.0.2 - Detailed Implementation Guide

**Release:** M1.0.2 - Core Integration  
**Status:** üü¢ Ready to Start  
**Duration:** 1-2 weeks  
**Target Completion:** January 23, 2026

---

## üìã IMPLEMENTATION ORDER

Execute features in this sequence to minimize dependencies:

1. **Day 1-2:** Address Update Integration
2. **Day 3:** Product Details with Specifications
3. **Day 4:** Add Bundle Filter to Existing Product Screen
4. **Day 5-8:** Disputes System (most complex)
5. **Day 9-10:** Remove Mock Data & Testing

---

## üè† FEATURE 1: ADDRESS UPDATE INTEGRATION

### Day 1-2 Implementation Plan

#### Step 1: Update Address Model (30 mins)
**File:** `lib/features/profile/data/models/address_model.dart`

**Action:** Add missing fields and validation methods

```dart
class AddressModel {
  final int? id;
  final String address;
  final double latitude;
  final double longitude;
  final String? title;
  final int? areaId;
  final String? areaName;
  final String? building;
  final String? apartment;
  final String? floor;
  final String? notes;
  final bool isDefault;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  AddressModel({
    this.id,
    required this.address,
    required this.latitude,
    required this.longitude,
    this.title,
    this.areaId,
    this.areaName,
    this.building,
    this.apartment,
    this.floor,
    this.notes,
    this.isDefault = false,
    this.createdAt,
    this.updatedAt,
  });

  // Validation methods
  ValidationResult validate() {
    final errors = <String>[];
    
    if (address.isEmpty || address.length > 500) {
      errors.add('Address must be between 1 and 500 characters');
    }
    
    if (latitude < -90.0 || latitude > 90.0) {
      errors.add('Invalid latitude');
    }
    
    if (longitude < -180.0 || longitude > 180.0) {
      errors.add('Invalid longitude');
    }
    
    if (title != null && title!.length > 100) {
      errors.add('Title must be max 100 characters');
    }
    
    if (building != null && building!.length > 50) {
      errors.add('Building must be max 50 characters');
    }
    
    if (apartment != null && apartment!.length > 50) {
      errors.add('Apartment must be max 50 characters');
    }
    
    if (floor != null && floor!.length > 20) {
      errors.add('Floor must be max 20 characters');
    }
    
    if (notes != null && notes!.length > 1000) {
      errors.add('Notes must be max 1000 characters');
    }
    
    return ValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'title': title ?? 'Address',
      'address': address,
      'latitude': latitude,
      'longitude': longitude,
      if (areaId != null) 'areaId': areaId,
      if (building != null) 'building': building,
      if (apartment != null) 'apartment': apartment,
      if (floor != null) 'floor': floor,
      if (notes != null) 'notes': notes,
      'isDefault': isDefault,
    };
  }

  factory AddressModel.fromJson(Map<String, dynamic> json) {
    return AddressModel(
      id: json['id'] as int?,
      address: json['address'] as String,
      latitude: (json['latitude'] as num).toDouble(),
      longitude: (json['longitude'] as num).toDouble(),
      title: json['title'] as String?,
      areaId: json['areaId'] as int?,
      areaName: json['areaName'] as String?,
      building: json['building'] as String?,
      apartment: json['apartment'] as String?,
      floor: json['floor'] as String?,
      notes: json['notes'] as String?,
      isDefault: json['isDefault'] as bool? ?? false,
      createdAt: json['createdAt'] != null 
          ? DateTime.parse(json['createdAt'] as String) 
          : null,
      updatedAt: json['updatedAt'] != null 
          ? DateTime.parse(json['updatedAt'] as String) 
          : null,
    );
  }

  AddressModel copyWith({
    int? id,
    String? address,
    double? latitude,
    double? longitude,
    String? title,
    int? areaId,
    String? areaName,
    String? building,
    String? apartment,
    String? floor,
    String? notes,
    bool? isDefault,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return AddressModel(
      id: id ?? this.id,
      address: address ?? this.address,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      title: title ?? this.title,
      areaId: areaId ?? this.areaId,
      areaName: areaName ?? this.areaName,
      building: building ?? this.building,
      apartment: apartment ?? this.apartment,
      floor: floor ?? this.floor,
      notes: notes ?? this.notes,
      isDefault: isDefault ?? this.isDefault,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

class ValidationResult {
  final bool isValid;
  final List<String> errors;

  ValidationResult({required this.isValid, required this.errors});
}
```

#### Step 2: Update Remote Data Source (45 mins)
**File:** `lib/features/profile/data/datasources/address_remote_datasource.dart`

**Action:** Add `updateAddress` method

```dart
abstract class AddressRemoteDataSource {
  Future<List<AddressModel>> getAddresses();
  Future<AddressModel> createAddress(AddressModel address);
  Future<AddressModel> updateAddress(int id, AddressModel address);
  Future<void> deleteAddress(int id);
}

class AddressRemoteDataSourceImpl implements AddressRemoteDataSource {
  final Dio dio;
  final AuthService authService;

  AddressRemoteDataSourceImpl({
    required this.dio,
    required this.authService,
  });

  @override
  Future<AddressModel> updateAddress(int id, AddressModel address) async {
    try {
      final token = await authService.getAccessToken();
      
      final response = await dio.put(
        '/v1/client/account/addresses/$id',
        data: address.toJson(),
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'Content-Type': 'application/json',
          },
        ),
      );

      if (response.statusCode == 200) {
        return AddressModel.fromJson(response.data);
      } else {
        throw ServerException(
          message: response.data['error']?['message'] ?? 'Failed to update address',
          code: response.data['error']?['code'] ?? 'UPDATE_FAILED',
        );
      }
    } on DioException catch (e) {
      if (e.response?.statusCode == 404) {
        throw NotFoundException('Address not found');
      } else if (e.response?.statusCode == 400) {
        final errorData = e.response?.data;
        throw ValidationException(
          message: errorData['error']?['message'] ?? 'Validation failed',
          details: errorData['error']?['details'] ?? [],
        );
      } else if (e.response?.statusCode == 401) {
        throw UnauthorizedException('Session expired');
      } else {
        throw ServerException(
          message: e.message ?? 'Network error',
          code: 'NETWORK_ERROR',
        );
      }
    }
  }
  
  // Other methods...
}
```

#### Step 3: Update Repository (30 mins)
**File:** `lib/features/profile/data/repositories/address_repository_impl.dart`

```dart
class AddressRepositoryImpl implements AddressRepository {
  final AddressRemoteDataSource remoteDataSource;

  AddressRepositoryImpl({required this.remoteDataSource});

  @override
  Future<Either<Failure, AddressModel>> updateAddress(
    int id,
    AddressModel address,
  ) async {
    try {
      final result = await remoteDataSource.updateAddress(id, address);
      return Right(result);
    } on ValidationException catch (e) {
      return Left(ValidationFailure(message: e.message, details: e.details));
    } on NotFoundException catch (e) {
      return Left(NotFoundFailure(message: e.message));
    } on UnauthorizedException catch (e) {
      return Left(UnauthorizedFailure(message: e.message));
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    }
  }
}
```

#### Step 4: Update Controller/Cubit (1 hour)
**File:** `lib/features/profile/presentation/controllers/address_controller.dart`

```dart
class AddressController extends GetxController {
  final AddressRepository repository;
  
  final addresses = <AddressModel>[].obs;
  final isLoading = false.obs;
  final errorMessage = ''.obs;

  AddressController({required this.repository});

  Future<void> updateAddress(int id, AddressModel address) async {
    try {
      // Validate before API call
      final validationResult = address.validate();
      if (!validationResult.isValid) {
        Get.snackbar(
          'Validation Error',
          validationResult.errors.join('\n'),
          backgroundColor: Colors.red,
          colorText: Colors.white,
          duration: Duration(seconds: 3),
        );
        return;
      }

      isLoading.value = true;
      errorMessage.value = '';

      final result = await repository.updateAddress(id, address);

      result.fold(
        (failure) {
          errorMessage.value = failure.message;
          Get.snackbar(
            'Error',
            failure.message,
            backgroundColor: Colors.red,
            colorText: Colors.white,
          );
        },
        (updatedAddress) {
          // Update local list
          final index = addresses.indexWhere((a) => a.id == id);
          if (index != -1) {
            addresses[index] = updatedAddress;
          }

          // If set as default, clear other defaults
          if (updatedAddress.isDefault) {
            for (int i = 0; i < addresses.length; i++) {
              if (addresses[i].id != id) {
                addresses[i] = addresses[i].copyWith(isDefault: false);
              }
            }
          }

          Get.back(); // Close edit dialog
          Get.snackbar(
            'Success',
            'Address updated successfully',
            backgroundColor: Colors.green,
            colorText: Colors.white,
          );
        },
      );
    } catch (e) {
      errorMessage.value = 'Unexpected error: $e';
      Get.snackbar(
        'Error',
        'Unexpected error occurred',
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    } finally {
      isLoading.value = false;
    }
  }
}
```

#### Step 5: Update UI Screen (2 hours)
**File:** Locate the address edit/add screen (likely in `lib/features/profile/presentation/screens/`)

**Changes needed:**
1. Connect form fields to controller
2. Add loading overlay
3. Disable submit during API call
4. Show validation errors
5. Handle success/error states

**Example implementation:**

```dart
class EditAddressScreen extends StatefulWidget {
  final AddressModel? address; // null for create, populated for edit

  const EditAddressScreen({this.address});

  @override
  _EditAddressScreenState createState() => _EditAddressScreenState();
}

class _EditAddressScreenState extends State<EditAddressScreen> {
  final _formKey = GlobalKey<FormState>();
  final _controller = Get.find<AddressController>();
  
  late TextEditingController _titleController;
  late TextEditingController _addressController;
  late TextEditingController _buildingController;
  late TextEditingController _apartmentController;
  late TextEditingController _floorController;
  late TextEditingController _notesController;
  
  double? _latitude;
  double? _longitude;
  int? _areaId;
  bool _isDefault = false;

  @override
  void initState() {
    super.initState();
    _initializeControllers();
  }

  void _initializeControllers() {
    final address = widget.address;
    _titleController = TextEditingController(text: address?.title ?? '');
    _addressController = TextEditingController(text: address?.address ?? '');
    _buildingController = TextEditingController(text: address?.building ?? '');
    _apartmentController = TextEditingController(text: address?.apartment ?? '');
    _floorController = TextEditingController(text: address?.floor ?? '');
    _notesController = TextEditingController(text: address?.notes ?? '');
    
    _latitude = address?.latitude;
    _longitude = address?.longitude;
    _areaId = address?.areaId;
    _isDefault = address?.isDefault ?? false;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.address == null ? 'Add Address' : 'Edit Address'),
      ),
      body: Obx(() {
        return Stack(
          children: [
            SingleChildScrollView(
              padding: EdgeInsets.all(16),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Title
                    TextFormField(
                      controller: _titleController,
                      decoration: InputDecoration(
                        labelText: 'Address Title (Optional)',
                        hintText: 'e.g., Home, Office',
                        border: OutlineInputBorder(),
                      ),
                      maxLength: 100,
                    ),
                    SizedBox(height: 16),
                    
                    // Address (Required)
                    TextFormField(
                      controller: _addressController,
                      decoration: InputDecoration(
                        labelText: 'Address *',
                        hintText: 'Building 45, Zone 52, Doha',
                        border: OutlineInputBorder(),
                      ),
                      maxLength: 500,
                      maxLines: 3,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Address is required';
                        }
                        return null;
                      },
                    ),
                    SizedBox(height: 16),
                    
                    // Map Location Picker
                    Container(
                      height: 200,
                      decoration: BoxDecoration(
                        border: Border.all(color: Colors.grey),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: GoogleMapLocationPicker(
                        initialLatitude: _latitude,
                        initialLongitude: _longitude,
                        onLocationSelected: (lat, lng) {
                          setState(() {
                            _latitude = lat;
                            _longitude = lng;
                          });
                        },
                      ),
                    ),
                    if (_latitude != null && _longitude != null)
                      Padding(
                        padding: EdgeInsets.only(top: 8),
                        child: Text(
                          'Location: ${_latitude!.toStringAsFixed(6)}, ${_longitude!.toStringAsFixed(6)}',
                          style: TextStyle(fontSize: 12, color: Colors.grey),
                        ),
                      ),
                    SizedBox(height: 16),
                    
                    // Building
                    TextFormField(
                      controller: _buildingController,
                      decoration: InputDecoration(
                        labelText: 'Building (Optional)',
                        border: OutlineInputBorder(),
                      ),
                      maxLength: 50,
                    ),
                    SizedBox(height: 16),
                    
                    // Apartment
                    TextFormField(
                      controller: _apartmentController,
                      decoration: InputDecoration(
                        labelText: 'Apartment (Optional)',
                        border: OutlineInputBorder(),
                      ),
                      maxLength: 50,
                    ),
                    SizedBox(height: 16),
                    
                    // Floor
                    TextFormField(
                      controller: _floorController,
                      decoration: InputDecoration(
                        labelText: 'Floor (Optional)',
                        border: OutlineInputBorder(),
                      ),
                      maxLength: 20,
                    ),
                    SizedBox(height: 16),
                    
                    // Notes
                    TextFormField(
                      controller: _notesController,
                      decoration: InputDecoration(
                        labelText: 'Delivery Notes (Optional)',
                        hintText: 'e.g., Ring doorbell twice',
                        border: OutlineInputBorder(),
                      ),
                      maxLength: 1000,
                      maxLines: 3,
                    ),
                    SizedBox(height: 16),
                    
                    // Set as Default
                    SwitchListTile(
                      title: Text('Set as default address'),
                      value: _isDefault,
                      onChanged: (value) {
                        setState(() => _isDefault = value);
                      },
                    ),
                    SizedBox(height: 24),
                    
                    // Submit Button
                    SizedBox(
                      width: double.infinity,
                      height: 48,
                      child: ElevatedButton(
                        onPressed: _controller.isLoading.value ? null : _submitForm,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppColors.primary,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                        child: Text(
                          widget.address == null ? 'Add Address' : 'Update Address',
                          style: TextStyle(color: Colors.white, fontSize: 16),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            
            // Loading Overlay
            if (_controller.isLoading.value)
              Container(
                color: Colors.black54,
                child: Center(
                  child: CircularProgressIndicator(),
                ),
              ),
          ],
        );
      }),
    );
  }

  void _submitForm() {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    if (_latitude == null || _longitude == null) {
      Get.snackbar(
        'Error',
        'Please select a location on the map',
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
      return;
    }

    final address = AddressModel(
      id: widget.address?.id,
      title: _titleController.text.isNotEmpty ? _titleController.text : null,
      address: _addressController.text,
      latitude: _latitude!,
      longitude: _longitude!,
      areaId: _areaId,
      building: _buildingController.text.isNotEmpty ? _buildingController.text : null,
      apartment: _apartmentController.text.isNotEmpty ? _apartmentController.text : null,
      floor: _floorController.text.isNotEmpty ? _floorController.text : null,
      notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      isDefault: _isDefault,
    );

    if (widget.address == null) {
      // Create new address
      _controller.createAddress(address);
    } else {
      // Update existing address
      _controller.updateAddress(widget.address!.id!, address);
    }
  }

  @override
  void dispose() {
    _titleController.dispose();
    _addressController.dispose();
    _buildingController.dispose();
    _apartmentController.dispose();
    _floorController.dispose();
    _notesController.dispose();
    super.dispose();
  }
}
```

#### Step 6: Testing (2 hours)

**Test Cases:**

1. **Happy Path - Update all fields**
   - Login with test account
   - Navigate to address list
   - Edit existing address
   - Fill all fields
   - Submit
   - Verify success message
   - Verify address list updates

2. **Partial Update - Required fields only**
   - Edit address
   - Fill only address, lat, lng
   - Leave optional fields empty
   - Submit
   - Verify success

3. **Validation Tests**
   - Try submitting with address > 500 chars
   - Try invalid GPS coordinates (e.g., lat = 100)
   - Try building > 50 chars
   - Verify validation errors shown

4. **Set as Default**
   - Set address as default
   - Verify other addresses become non-default
   - Check in address list

5. **Error Handling**
   - Test with invalid address ID (404)
   - Test with expired token (401, should auto-refresh)
   - Test with network offline

---

## üõçÔ∏è FEATURE 2: PRODUCT DETAILS WITH SPECIFICATIONS

### Day 3 Implementation Plan

#### Step 1: Update Product Model (1 hour)

**File:** `lib/features/products/data/models/product_model.dart`

**Add nested models:**

```dart
class ProductSpecification {
  final int id;
  final String nameEn;
  final String nameAr;
  final String value;
  final String? unit;
  final int displayOrder;
  final bool isHighlighted;

  ProductSpecification({
    required this.id,
    required this.nameEn,
    required this.nameAr,
    required this.value,
    this.unit,
    required this.displayOrder,
    required this.isHighlighted,
  });

  factory ProductSpecification.fromJson(Map<String, dynamic> json) {
    return ProductSpecification(
      id: json['id'] as int,
      nameEn: json['nameEn'] as String,
      nameAr: json['nameAr'] as String,
      value: json['value'] as String,
      unit: json['unit'] as String?,
      displayOrder: json['displayOrder'] as int,
      isHighlighted: json['isHighlighted'] as bool,
    );
  }

  String get localizedName {
    final locale = Get.locale?.languageCode ?? 'en';
    return locale == 'ar' ? nameAr : nameEn;
  }

  String get formattedValue {
    if (unit != null && unit!.isNotEmpty) {
      return '$value $unit';
    }
    return value;
  }
}

class ProductImage {
  final int documentId;
  final String filePath;
  final bool isPrimary;

  ProductImage({
    required this.documentId,
    required this.filePath,
    required this.isPrimary,
  });

  factory ProductImage.fromJson(Map<String, dynamic> json) {
    return ProductImage(
      documentId: json['documentId'] as int,
      filePath: json['filePath'] as String,
      isPrimary: json['isPrimary'] as bool,
    );
  }
}

class InventoryLocation {
  final int terminalId;
  final String terminalName;
  final double quantity;

  InventoryLocation({
    required this.terminalId,
    required this.terminalName,
    required this.quantity,
  });

  factory InventoryLocation.fromJson(Map<String, dynamic> json) {
    return InventoryLocation(
      terminalId: json['terminalId'] as int,
      terminalName: json['terminalName'] as String,
      quantity: (json['quantity'] as num).toDouble(),
    );
  }
}
```

**Update main ProductModel:**

```dart
class ProductModel {
  // Existing fields...
  final int id;
  final int vsid;
  final String enName;
  final String arName;
  final double price;
  final int? categoryId;
  final String? categoryName;
  final bool isBundle;
  final int? supplierId;
  final String? supplierName;
  
  // NEW FIELDS
  final String? description;
  final String? brand;
  final List<ProductSpecification> specifications;
  final List<ProductImage> images;
  final double totalAvailableQuantity;
  final List<InventoryLocation> inventory;

  ProductModel({
    required this.id,
    required this.vsid,
    required this.enName,
    required this.arName,
    required this.price,
    this.categoryId,
    this.categoryName,
    required this.isBundle,
    this.supplierId,
    this.supplierName,
    this.description,
    this.brand,
    this.specifications = const [],
    this.images = const [],
    required this.totalAvailableQuantity,
    this.inventory = const [],
  });

  factory ProductModel.fromJson(Map<String, dynamic> json) {
    return ProductModel(
      id: json['id'] as int,
      vsid: json['vsid'] as int,
      enName: json['enName'] as String,
      arName: json['arName'] as String,
      price: (json['price'] as num).toDouble(),
      categoryId: json['categoryId'] as int?,
      categoryName: json['categoryName'] as String?,
      isBundle: json['isBundle'] as bool? ?? false,
      supplierId: json['supplierId'] as int?,
      supplierName: json['supplierName'] as String?,
      description: json['description'] as String?,
      brand: json['brand'] as String?,
      specifications: (json['specifications'] as List<dynamic>?)
          ?.map((e) => ProductSpecification.fromJson(e as Map<String, dynamic>))
          .toList() ?? [],
      images: (json['images'] as List<dynamic>?)
          ?.map((e) => ProductImage.fromJson(e as Map<String, dynamic>))
          .toList() ?? [],
      totalAvailableQuantity: (json['totalAvailableQuantity'] as num?)?.toDouble() ?? 0.0,
      inventory: (json['inventory'] as List<dynamic>?)
          ?.map((e) => InventoryLocation.fromJson(e as Map<String, dynamic>))
          .toList() ?? [],
    );
  }

  // Helper getters
  bool get isInStock => totalAvailableQuantity > 0;
  bool get isLowStock => totalAvailableQuantity > 0 && totalAvailableQuantity < 10;
  
  ProductImage? get primaryImage => images.firstWhereOrNull((img) => img.isPrimary);
  List<ProductImage> get galleryImages => images.where((img) => !img.isPrimary).toList();
  List<ProductImage> get allImagesOrdered {
    final primary = primaryImage;
    if (primary == null) return images;
    return [primary, ...galleryImages];
  }
  
  List<ProductSpecification> get highlightedSpecs => 
      specifications.where((spec) => spec.isHighlighted).toList()
        ..sort((a, b) => a.displayOrder.compareTo(b.displayOrder));
  
  List<ProductSpecification> get allSpecsOrdered =>
      [...specifications]..sort((a, b) => a.displayOrder.compareTo(b.displayOrder));
  
  String get stockStatus {
    if (!isInStock) return 'Out of Stock';
    if (isLowStock) return 'Low Stock';
    return 'In Stock';
  }
  
  Color get stockStatusColor {
    if (!isInStock) return Colors.red;
    if (isLowStock) return Colors.orange;
    return Colors.green;
  }
}
```

#### Step 2: Update Product Details Screen (3 hours)

**File:** Locate product details screen (likely `lib/features/products/presentation/screens/product_details_screen.dart`)

**Add Specifications Tab:**

```dart
class ProductDetailsScreen extends StatefulWidget {
  final ProductModel product;

  const ProductDetailsScreen({required this.product});

  @override
  _ProductDetailsScreenState createState() => _ProductDetailsScreenState();
}

class _ProductDetailsScreenState extends State<ProductDetailsScreen> 
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _currentImageIndex = 0;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsController: this);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.product.enName),
      ),
      body: Column(
        children: [
          // Image Gallery
          _buildImageGallery(),
          
          // Stock Status Badge
          _buildStockBadge(),
          
          // Tabs
          TabBar(
            controller: _tabController,
            tabs: [
              Tab(text: 'Overview'),
              Tab(text: 'Specifications'),
              Tab(text: 'Reviews'),
            ],
          ),
          
          // Tab Views
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildOverviewTab(),
                _buildSpecificationsTab(),
                _buildReviewsTab(),
              ],
            ),
          ),
          
          // Add to Cart Button
          _buildAddToCartButton(),
        ],
      ),
    );
  }

  Widget _buildImageGallery() {
    final images = widget.product.allImagesOrdered;
    
    if (images.isEmpty) {
      return Container(
        height: 300,
        color: Colors.grey[200],
        child: Icon(Icons.image, size: 80, color: Colors.grey),
      );
    }

    return Container(
      height: 300,
      child: Stack(
        children: [
          PageView.builder(
            itemCount: images.length,
            onPageChanged: (index) {
              setState(() => _currentImageIndex = index);
            },
            itemBuilder: (context, index) {
              return CachedNetworkImage(
                imageUrl: images[index].filePath,
                fit: BoxFit.cover,
                placeholder: (context, url) => Center(
                  child: CircularProgressIndicator(),
                ),
                errorWidget: (context, url, error) => Icon(Icons.error),
              );
            },
          ),
          
          // Image indicator dots
          if (images.length > 1)
            Positioned(
              bottom: 16,
              left: 0,
              right: 0,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: List.generate(images.length, (index) {
                  return Container(
                    margin: EdgeInsets.symmetric(horizontal: 4),
                    width: 8,
                    height: 8,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      color: _currentImageIndex == index
                          ? Colors.white
                          : Colors.white.withOpacity(0.5),
                    ),
                  );
                }),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildStockBadge() {
    return Container(
      padding: EdgeInsets.all(12),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            '\$${widget.product.price.toStringAsFixed(2)} QAR',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: AppColors.primary,
            ),
          ),
          Container(
            padding: EdgeInsets.symmetric(horizontal: 12, vertical: 6),
            decoration: BoxDecoration(
              color: widget.product.stockStatusColor,
              borderRadius: BorderRadius.circular(20),
            ),
            child: Text(
              widget.product.stockStatus,
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildOverviewTab() {
    return SingleChildScrollView(
      padding: EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (widget.product.brand != null) ...[
            Text('Brand', style: TextStyle(fontWeight: FontWeight.bold)),
            SizedBox(height: 4),
            Text(widget.product.brand!),
            SizedBox(height: 16),
          ],
          
          if (widget.product.description != null) ...[
            Text('Description', style: TextStyle(fontWeight: FontWeight.bold)),
            SizedBox(height: 8),
            Text(
              widget.product.description!,
              style: TextStyle(height: 1.5),
            ),
            SizedBox(height: 16),
          ],
          
          if (widget.product.supplierName != null) ...[
            Text('Supplier', style: TextStyle(fontWeight: FontWeight.bold)),
            SizedBox(height: 4),
            Text(widget.product.supplierName!),
            SizedBox(height: 16),
          ],
          
          // Highlighted Specifications Preview
          if (widget.product.highlightedSpecs.isNotEmpty) ...[
            Text('Key Specifications', style: TextStyle(fontWeight: FontWeight.bold)),
            SizedBox(height: 8),
            ...widget.product.highlightedSpecs.take(3).map((spec) {
              return Padding(
                padding: EdgeInsets.only(bottom: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(spec.localizedName),
                    Text(
                      spec.formattedValue,
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                  ],
                ),
              );
            }).toList(),
            TextButton(
              onPressed: () => _tabController.animateTo(1),
              child: Text('View All Specifications ‚Üí'),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildSpecificationsTab() {
    if (widget.product.specifications.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.info_outline, size: 60, color: Colors.grey),
            SizedBox(height: 16),
            Text(
              'No specifications available',
              style: TextStyle(color: Colors.grey),
            ),
          ],
        ),
      );
    }

    return ListView(
      padding: EdgeInsets.all(16),
      children: [
        ...widget.product.allSpecsOrdered.map((spec) {
          return Container(
            margin: EdgeInsets.only(bottom: 12),
            padding: EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: spec.isHighlighted 
                  ? AppColors.primary.withOpacity(0.1)
                  : Colors.grey.withOpacity(0.05),
              borderRadius: BorderRadius.circular(8),
              border: spec.isHighlighted
                  ? Border.all(color: AppColors.primary.withOpacity(0.3))
                  : null,
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Text(
                    spec.localizedName,
                    style: TextStyle(
                      fontWeight: spec.isHighlighted 
                          ? FontWeight.bold 
                          : FontWeight.w500,
                    ),
                  ),
                ),
                Text(
                  spec.formattedValue,
                  style: TextStyle(
                    color: Colors.grey[700],
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          );
        }).toList(),
      ],
    );
  }

  Widget _buildReviewsTab() {
    // Existing reviews implementation
    return Center(child: Text('Reviews tab'));
  }

  Widget _buildAddToCartButton() {
    return Container(
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black12,
            blurRadius: 4,
            offset: Offset(0, -2),
          ),
        ],
      ),
      child: SizedBox(
        width: double.infinity,
        height: 48,
        child: ElevatedButton(
          onPressed: widget.product.isInStock ? _addToCart : null,
          style: ElevatedButton.styleFrom(
            backgroundColor: AppColors.primary,
            disabledBackgroundColor: Colors.grey,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
          child: Text(
            widget.product.isInStock ? 'Add to Cart' : 'Out of Stock',
            style: TextStyle(color: Colors.white, fontSize: 16),
          ),
        ),
      ),
    );
  }

  void _addToCart() {
    // Existing add to cart logic
    Get.find<CartController>().addItem(widget.product);
    Get.snackbar('Success', 'Added to cart');
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }
}
```

#### Step 3: Testing (1 hour)

**Test Cases:**
1. Product with full specifications
2. Product with no specifications
3. Product with single image
4. Product with multiple images
5. Out of stock product
6. Low stock product
7. Arabic locale spec display

---

## üì¶ FEATURE 3: BUNDLE PRODUCTS FILTER

### Day 4 Implementation Plan

**‚ö†Ô∏è NO NEW SCREENS - Use Existing `AllProductScreen`**

The app already has a product listing screen. Simply add `isBundle` filter to the existing `ProductsEvent` to display bundle products.

#### Step 1: Add isBundle Parameter to ProductsEvent (30 mins)

**File:** `lib/features/home/presentation/bloc/products_bloc/products_event.dart`

Add `isBundle` parameter:

```dart
class ProductsEvent extends Equatable {
  final int? categoryId;
  final double? minPrice;
  final double? maxPrice;
  final bool? isActive;
  final int? supplierId;
  final int? pageSize;
  final int? pageIndex;
  final String? searchTerm;
  final String? sortBy;
  final bool? isDescending;
  final bool? executeClear;
  final bool? isBundle;  // üëà ADD THIS

  const ProductsEvent({
    this.categoryId,
    this.minPrice,
    this.maxPrice,
    this.isActive,
    this.supplierId,
    this.pageSize,
    this.pageIndex,
    this.searchTerm,
    this.sortBy,
    this.isDescending,
    this.executeClear,
    this.isBundle,  // üëà ADD THIS
  });

  @override
  List<Object?> get props => [
        categoryId,
        minPrice,
        maxPrice,
        isActive,
        supplierId,
        pageSize,
        pageIndex,
        searchTerm,
        sortBy,
        isDescending,
        executeClear,
        isBundle,  // üëà ADD THIS
      ];
}

class FetchProducts extends ProductsEvent {
  const FetchProducts({
    super.categoryId,
    super.minPrice,
    super.maxPrice,
    super.isActive,
    super.supplierId,
    super.pageSize = 10,
    super.pageIndex = 1,
    super.searchTerm,
    super.sortBy,
    super.isDescending,
    super.executeClear = false,
    super.isBundle,  // üëà ADD THIS
  });
}
```

#### Step 2: Update Products Bloc to Handle isBundle (30 mins)

**File:** `lib/features/home/presentation/bloc/products_bloc/products_bloc.dart`

Update the API call to include `isBundle` query parameter:

```dart
// In your API call method, add isBundle to query parameters
final queryParams = {
  if (event.categoryId != null) 'categoryId': event.categoryId,
  if (event.supplierId != null) 'supplierId': event.supplierId,
  if (event.minPrice != null) 'minPrice': event.minPrice,
  if (event.maxPrice != null) 'maxPrice': event.maxPrice,
  if (event.searchTerm != null) 'searchTerm': event.searchTerm,
  if (event.sortBy != null) 'sortBy': event.sortBy,
  if (event.isDescending != null) 'isDescending': event.isDescending,
  if (event.isBundle != null) 'isBundle': event.isBundle,  // üëà ADD THIS
  'pageNumber': event.pageIndex,
  'pageSize': event.pageSize,
};
```

#### Step 3: Navigate to Bundles View (15 mins)

**Usage:** When user clicks "View Bundles" button (wherever it is in your signed-off UI), navigate to `AllProductScreen` with `isBundle=true`:

```dart
// Example: In your home screen or wherever bundles link exists
onTap: () {
  // Navigate to existing product screen with bundle filter
  Navigator.push(
    context,
    MaterialPageRoute(
      builder: (context) => AllProductScreen(),
    ),
  );
  
  // Trigger fetch with isBundle=true
  context.read<ProductsBloc>().add(
    FetchProducts(
      isBundle: true,
      executeClear: true,
    ),
  );
}
```

#### Step 4: Testing (1 hour)

**Test Cases:**

1. **Filter bundles only**
   - Navigate with `isBundle=true`
   - Verify only bundle products displayed
   - Check product cards show bundle badge (if in UI design)

2. **Pagination with bundles**
   - Scroll to bottom
   - Verify more bundles load
   - Check page numbers increment

3. **Combined filters**
   - Filter bundles by supplier
   - Filter bundles by price range
   - Verify correct results

4. **API Verification**
   - Check network logs
   - Confirm `isBundle=true` sent in query params
   - Verify response contains only bundles

**API Endpoint:** `GET /api/v1/client/products?isBundle=true&pageNumber=1&pageSize=20`

---

## üö® FEATURE 4: DISPUTES SYSTEM

### Day 5-8 Implementation Plan

**TODO:** Add Disputes System implementation details

---

## ‚úÖ COMPLETION CHECKLIST

### Before Starting M1.0.2
- [ ] All team members review this guide
- [ ] Development environment setup complete
- [ ] Test account credentials verified
- [ ] Swagger documentation accessible
- [ ] Git branch created for M1.0.2

### Daily Progress Tracking
- [ ] Daily standup to review completed tasks
- [ ] Update task status in project management tool
- [ ] Test each feature immediately after implementation
- [ ] Document any blockers or issues

### Before Release
- [ ] All acceptance criteria met
- [ ] All test cases passed
- [ ] Code review completed
- [ ] QA testing on production with test account
- [ ] Performance tested (pagination, image loading)
- [ ] No console errors or warnings

---

**END OF M1.0.2 DETAILED IMPLEMENTATION GUIDE**
