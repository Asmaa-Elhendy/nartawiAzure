# M1.0.4 - Notifications & Reviews (REVISED)

**Status:** ‚úÖ Ready to Start  
**Duration:** 7 hours  
**Design Compliance:** üü¢ No new screens - uses existing UI only  
**Backend APIs:** All confirmed ready

---

## üéØ OVERVIEW

This guide integrates backend APIs into **existing screens only**:
- ‚úÖ Existing `notification_screen.dart` ‚Üí Connect to notifications API
- ‚úÖ Existing `settings.dart` ‚Üí Connect preferences toggles to API
- ‚úÖ Existing `review_alert_dialog.dart` ‚Üí Add review submission

**NO NEW SCREENS CREATED** - Strict adherence to signed-off UI design.

---

## üì¶ FEATURE 1: NOTIFICATIONS API INTEGRATION

### Existing Screen
**File:** `lib/features/notification/presentation/pages/notification_screen.dart`

**Current State:**
- ‚úÖ Full UI with tabs (All, New, Read, Orders, Coupons, Promos)
- ‚úÖ Notification cards with title, description
- ‚ö†Ô∏è Uses hardcoded mock data

**Goal:** Replace mock data with backend API

---

### Step 1.1: Update Notification Model (30 mins)

**File:** `lib/features/notification/domain/notification_model.dart`

**Current model:**
```dart
class NotificationModel {
  final int id;
  final String title;
  final String description;
  bool isChecked;
  bool isRead;
}
```

**Replace with:**
```dart
class NotificationModel {
  final int id;
  final String title;
  final String message;
  final String type;
  final bool isRead;
  final String? relatedEntityType;
  final int? relatedEntityId;
  final DateTime createdAt;
  final DateTime? readAt;

  NotificationModel({
    required this.id,
    required this.title,
    required this.message,
    required this.type,
    required this.isRead,
    this.relatedEntityType,
    this.relatedEntityId,
    required this.createdAt,
    this.readAt,
  });

  factory NotificationModel.fromJson(Map<String, dynamic> json) {
    return NotificationModel(
      id: json['id'] as int,
      title: json['title'] as String,
      message: json['message'] as String,
      type: json['type'] as String,
      isRead: json['isRead'] as bool? ?? false,
      relatedEntityType: json['relatedEntityType'] as String?,
      relatedEntityId: json['relatedEntityId'] as int?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      readAt: json['readAt'] != null 
          ? DateTime.parse(json['readAt'] as String) 
          : null,
    );
  }

  // Helpers for UI
  IconData get icon {
    switch (type) {
      case 'ORDER_UPDATE':
        return Icons.shopping_bag;
      case 'SCHEDULED_ORDER_REMINDER':
        return Icons.schedule;
      case 'DISPUTE_UPDATE':
        return Icons.report_problem;
      case 'MARKETING':
        return Icons.local_offer;
      case 'SYSTEM':
        return Icons.info;
      default:
        return Icons.notifications;
    }
  }

  Color get iconColor {
    switch (type) {
      case 'ORDER_UPDATE':
        return Colors.blue;
      case 'SCHEDULED_ORDER_REMINDER':
        return Colors.orange;
      case 'DISPUTE_UPDATE':
        return Colors.red;
      case 'MARKETING':
        return Colors.green;
      case 'SYSTEM':
        return Colors.grey;
      default:
        return Colors.grey;
    }
  }

  String get timeAgo {
    final now = DateTime.now();
    final difference = now.difference(createdAt);

    if (difference.inDays > 7) {
      return DateFormat('MMM d, yyyy').format(createdAt.toLocal());
    } else if (difference.inDays > 0) {
      return '${difference.inDays}d ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours}h ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes}m ago';
    } else {
      return 'Just now';
    }
  }

  // Map backend type to existing tab categories
  String get category {
    switch (type) {
      case 'ORDER_UPDATE':
        return 'Orders';
      case 'SCHEDULED_ORDER_REMINDER':
        return 'Coupons';
      case 'MARKETING':
        return 'Promos';
      default:
        return 'All';
    }
  }
}

class NotificationsPaginatedResponse {
  final List<NotificationModel> items;
  final int currentPage;
  final int totalPages;
  final int totalCount;
  final bool hasNextPage;

  NotificationsPaginatedResponse({
    required this.items,
    required this.currentPage,
    required this.totalPages,
    required this.totalCount,
    required this.hasNextPage,
  });

  factory NotificationsPaginatedResponse.fromJson(Map<String, dynamic> json) {
    return NotificationsPaginatedResponse(
      items: (json['items'] as List<dynamic>)
          .map((e) => NotificationModel.fromJson(e as Map<String, dynamic>))
          .toList(),
      currentPage: json['pagination']['currentPage'] as int,
      totalPages: json['pagination']['totalPages'] as int,
      totalCount: json['pagination']['totalCount'] as int,
      hasNextPage: json['pagination']['hasNextPage'] as bool? ?? false,
    );
  }
}
```

---

### Step 1.2: Create Remote Data Source (1 hour)

**File:** `lib/features/notification/data/datasources/notification_remote_datasource.dart`

```dart
import 'package:dio/dio.dart';
import '../../domain/notification_model.dart';
import '../../../../core/services/auth_service.dart';

abstract class NotificationRemoteDataSource {
  Future<NotificationsPaginatedResponse> getNotifications({
    int pageNumber = 1,
    int pageSize = 20,
    bool? isRead,
  });
  Future<int> getUnreadCount();
  Future<void> markAsRead(int id);
  Future<int> markAllAsRead();
  Future<void> registerFCMToken({
    required String token,
    required String deviceType,
    required String deviceId,
  });
}

class NotificationRemoteDataSourceImpl implements NotificationRemoteDataSource {
  final Dio dio;
  static const String baseUrl = 'https://nartawi.smartvillageqatar.com/api';

  NotificationRemoteDataSourceImpl({required this.dio});

  @override
  Future<NotificationsPaginatedResponse> getNotifications({
    int pageNumber = 1,
    int pageSize = 20,
    bool? isRead,
  }) async {
    try {
      final token = await AuthService.getToken();
      
      final queryParams = <String, dynamic>{
        'pageNumber': pageNumber,
        'pageSize': pageSize,
      };
      if (isRead != null) queryParams['isRead'] = isRead;

      print('üîµ Fetching notifications: page=$pageNumber, isRead=$isRead');

      final response = await dio.get(
        '$baseUrl/v1/client/notifications',
        queryParameters: queryParams,
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'accept': 'application/json',
          },
        ),
      );

      if (response.statusCode == 200) {
        return NotificationsPaginatedResponse.fromJson(
          response.data as Map<String, dynamic>,
        );
      } else {
        throw Exception('Failed to fetch notifications');
      }
    } on DioException catch (e) {
      print('‚ùå DioException: ${e.response?.data}');
      throw Exception(e.response?.data?['title'] ?? 'Network error');
    }
  }

  @override
  Future<int> getUnreadCount() async {
    try {
      final token = await AuthService.getToken();

      final response = await dio.get(
        '$baseUrl/v1/client/notifications/unread-count',
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'accept': 'application/json',
          },
        ),
      );

      if (response.statusCode == 200) {
        return response.data['unreadCount'] as int;
      } else {
        throw Exception('Failed to fetch unread count');
      }
    } catch (e) {
      print('‚ùå Error fetching unread count: $e');
      return 0;
    }
  }

  @override
  Future<void> markAsRead(int id) async {
    try {
      final token = await AuthService.getToken();

      final response = await dio.post(
        '$baseUrl/v1/client/notifications/$id/read',
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'accept': 'application/json',
          },
        ),
      );

      if (response.statusCode != 200) {
        throw Exception('Failed to mark as read');
      }
    } catch (e) {
      print('‚ùå Error marking as read: $e');
      throw Exception('Failed to mark notification as read');
    }
  }

  @override
  Future<int> markAllAsRead() async {
    try {
      final token = await AuthService.getToken();

      final response = await dio.post(
        '$baseUrl/v1/client/notifications/read-all',
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'accept': 'application/json',
          },
        ),
      );

      if (response.statusCode == 200) {
        return response.data['markedCount'] as int? ?? 0;
      } else {
        throw Exception('Failed to mark all as read');
      }
    } catch (e) {
      print('‚ùå Error marking all as read: $e');
      throw Exception('Failed to mark all as read');
    }
  }

  @override
  Future<void> registerFCMToken({
    required String token,
    required String deviceType,
    required String deviceId,
  }) async {
    try {
      final authToken = await AuthService.getToken();

      await dio.post(
        '$baseUrl/v1/client/notifications/push-tokens',
        data: {
          'token': token,
          'deviceType': deviceType,
          'deviceId': deviceId,
        },
        options: Options(
          headers: {
            'Authorization': 'Bearer $authToken',
            'Content-Type': 'application/json',
            'accept': 'application/json',
          },
        ),
      );

      print('‚úÖ FCM token registered');
    } catch (e) {
      print('‚ùå Failed to register FCM token: $e');
    }
  }
}
```

---

### Step 1.3: Create Notification Controller (1 hour)

**File:** `lib/features/notification/presentation/provider/notification_controller.dart`

```dart
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import '../../domain/notification_model.dart';
import '../../data/datasources/notification_remote_datasource.dart';

class NotificationController extends ChangeNotifier {
  final NotificationRemoteDataSource _dataSource;

  NotificationController({required Dio dio})
      : _dataSource = NotificationRemoteDataSourceImpl(dio: dio);

  List<NotificationModel> _allNotifications = [];
  bool _isLoading = false;
  String? _error;
  int _unreadCount = 0;

  int _currentPage = 1;
  int _totalPages = 1;
  bool _hasMore = true;

  List<NotificationModel> get allNotifications => _allNotifications;
  bool get isLoading => _isLoading;
  String? get error => _error;
  int get unreadCount => _unreadCount;
  bool get hasMore => _hasMore;

  // Filter by tab
  List<NotificationModel> getNotificationsByTab(String tab) {
    if (tab == 'All') return _allNotifications;
    if (tab == 'New') return _allNotifications.where((n) => !n.isRead).toList();
    if (tab == 'Read') return _allNotifications.where((n) => n.isRead).toList();
    
    // Map to categories
    return _allNotifications.where((n) => n.category == tab).toList();
  }

  Future<void> fetchNotifications({bool loadMore = false}) async {
    if (_isLoading) return;

    _isLoading = true;
    _error = null;
    if (!loadMore) {
      _currentPage = 1;
      _allNotifications.clear();
    }
    notifyListeners();

    try {
      final response = await _dataSource.getNotifications(
        pageNumber: _currentPage,
        pageSize: 20,
      );

      _allNotifications.addAll(response.items);
      _totalPages = response.totalPages;
      _hasMore = response.hasNextPage;

      if (loadMore) _currentPage++;

      await refreshUnreadCount();
    } catch (e) {
      _error = e.toString();
      debugPrint('‚ùå Error fetching notifications: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> refreshUnreadCount() async {
    try {
      _unreadCount = await _dataSource.getUnreadCount();
      notifyListeners();
    } catch (e) {
      debugPrint('‚ùå Error refreshing unread count: $e');
    }
  }

  Future<void> markAsRead(int id) async {
    try {
      await _dataSource.markAsRead(id);
      
      final index = _allNotifications.indexWhere((n) => n.id == id);
      if (index != -1) {
        _allNotifications[index] = NotificationModel(
          id: _allNotifications[index].id,
          title: _allNotifications[index].title,
          message: _allNotifications[index].message,
          type: _allNotifications[index].type,
          isRead: true,
          relatedEntityType: _allNotifications[index].relatedEntityType,
          relatedEntityId: _allNotifications[index].relatedEntityId,
          createdAt: _allNotifications[index].createdAt,
          readAt: DateTime.now(),
        );
      }

      _unreadCount = (_unreadCount - 1).clamp(0, 999);
      notifyListeners();
    } catch (e) {
      debugPrint('‚ùå Error marking as read: $e');
    }
  }

  Future<void> markAllAsRead() async {
    try {
      final count = await _dataSource.markAllAsRead();
      
      _allNotifications = _allNotifications.map((n) {
        return NotificationModel(
          id: n.id,
          title: n.title,
          message: n.message,
          type: n.type,
          isRead: true,
          relatedEntityType: n.relatedEntityType,
          relatedEntityId: n.relatedEntityId,
          createdAt: n.createdAt,
          readAt: DateTime.now(),
        );
      }).toList();

      _unreadCount = 0;
      notifyListeners();
    } catch (e) {
      debugPrint('‚ùå Error marking all as read: $e');
    }
  }

  Future<void> registerFCMToken({
    required String token,
    required String deviceType,
    required String deviceId,
  }) async {
    await _dataSource.registerFCMToken(
      token: token,
      deviceType: deviceType,
      deviceId: deviceId,
    );
  }
}
```

---

### Step 1.4: Update Existing Notification Screen (1.5 hours)

**File:** `lib/features/notification/presentation/pages/notification_screen.dart`

**Changes needed:**

1. Add controller initialization
2. Replace hardcoded data with API calls
3. Add pull-to-refresh
4. Add pagination on scroll
5. Add mark as read on tap
6. Add "Mark all read" button

**Implementation:**

```dart
// Add at top of file
import 'package:dio/dio.dart';
import '../provider/notification_controller.dart';

// Update _NotificationScreenState
class _NotificationScreenState extends State<NotificationScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  late NotificationController _notificationController;
  late ScrollController _scrollController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: _tabs.length, vsync: this);
    _scrollController = ScrollController();
    _notificationController = NotificationController(dio: Dio());
    
    // Fetch notifications
    _notificationController.fetchNotifications();
    
    // Poll every 60 seconds
    _startPolling();
    
    // Pagination listener
    _scrollController.addListener(_onScroll);
  }

  void _startPolling() {
    Future.delayed(Duration(seconds: 60), () {
      if (mounted) {
        _notificationController.refreshUnreadCount();
        _startPolling();
      }
    });
  }

  void _onScroll() {
    if (_scrollController.position.pixels >= 
        _scrollController.position.maxScrollExtent - 200) {
      if (_notificationController.hasMore) {
        _notificationController.fetchNotifications(loadMore: true);
      }
    }
  }

  @override
  void dispose() {
    _tabController.dispose();
    _scrollController.dispose();
    _notificationController.dispose();
    super.dispose();
  }

  // Replace _buildTabPage method
  Widget _buildTabPage(String tabName) {
    return ChangeNotifierProvider.value(
      value: _notificationController,
      child: Consumer<NotificationController>(
        builder: (context, controller, child) {
          if (controller.isLoading && controller.allNotifications.isEmpty) {
            return Center(child: CircularProgressIndicator());
          }

          if (controller.error != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text('Error: ${controller.error}'),
                  ElevatedButton(
                    onPressed: () => controller.fetchNotifications(),
                    child: Text('Retry'),
                  ),
                ],
              ),
            );
          }

          final notifications = controller.getNotificationsByTab(tabName);

          if (notifications.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.notifications_none, size: 80, color: Colors.grey),
                  SizedBox(height: 16),
                  Text('No notifications', style: TextStyle(color: Colors.grey)),
                ],
              ),
            );
          }

          return RefreshIndicator(
            onRefresh: () => controller.fetchNotifications(),
            child: ListView.builder(
              controller: _scrollController,
              itemCount: notifications.length + (controller.isLoading ? 1 : 0),
              itemBuilder: (context, index) {
                if (index >= notifications.length) {
                  return Padding(
                    padding: EdgeInsets.all(16),
                    child: Center(child: CircularProgressIndicator()),
                  );
                }

                final notification = notifications[index];
                return _buildNotificationCard(notification);
              },
            ),
          );
        },
      ),
    );
  }

  Widget _buildNotificationCard(NotificationModel notification) {
    return InkWell(
      onTap: () => _handleNotificationTap(notification),
      child: Container(
        color: notification.isRead ? Colors.white : Colors.blue.withOpacity(0.05),
        padding: EdgeInsets.all(16),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Icon
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: notification.iconColor.withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(notification.icon, color: notification.iconColor, size: 20),
            ),
            SizedBox(width: 12),
            
            // Content
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Expanded(
                        child: Text(
                          notification.title,
                          style: TextStyle(
                            fontWeight: notification.isRead 
                                ? FontWeight.normal 
                                : FontWeight.bold,
                            fontSize: 15,
                          ),
                        ),
                      ),
                      if (!notification.isRead)
                        Container(
                          width: 8,
                          height: 8,
                          decoration: BoxDecoration(
                            color: Colors.blue,
                            shape: BoxShape.circle,
                          ),
                        ),
                    ],
                  ),
                  SizedBox(height: 4),
                  Text(
                    notification.message,
                    style: TextStyle(fontSize: 14, color: Colors.grey[700]),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  SizedBox(height: 4),
                  Text(
                    notification.timeAgo,
                    style: TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _handleNotificationTap(NotificationModel notification) async {
    // Mark as read
    if (!notification.isRead) {
      await _notificationController.markAsRead(notification.id);
    }

    // Navigate if has related entity
    if (notification.relatedEntityType != null && 
        notification.relatedEntityId != null) {
      // Add navigation logic based on entity type
      // Navigator.push(...) to relevant screen
    }
  }
}
```

**Add "Mark all read" button to AppBar:**
```dart
BuildForegroundappbarhome(
  // ... existing params
  actions: [
    Consumer<NotificationController>(
      builder: (context, controller, child) {
        if (controller.allNotifications.isEmpty) return SizedBox.shrink();
        
        return TextButton(
          onPressed: () => controller.markAllAsRead(),
          child: Text(
            'Mark all read',
            style: TextStyle(color: Colors.white),
          ),
        );
      },
    ),
  ],
),
```

---

### Step 1.5: Add Unread Badge to App Bar (30 mins)

**File:** Update main app bar (e.g., `build_ForegroundAppBarHome.dart` or home screen)

```dart
// In app bar actions
Stack(
  children: [
    IconButton(
      icon: Icon(Icons.notifications),
      onPressed: () {
        Navigator.push(
          context,
          MaterialPageRoute(builder: (_) => NotificationScreen()),
        );
      },
    ),
    Consumer<NotificationController>(
      builder: (context, controller, child) {
        if (controller.unreadCount == 0) return SizedBox.shrink();
        
        return Positioned(
          right: 8,
          top: 8,
          child: Container(
            padding: EdgeInsets.all(4),
            decoration: BoxDecoration(
              color: Colors.red,
              shape: BoxShape.circle,
            ),
            constraints: BoxConstraints(minWidth: 16, minHeight: 16),
            child: Text(
              controller.unreadCount > 99 
                  ? '99+' 
                  : controller.unreadCount.toString(),
              style: TextStyle(
                color: Colors.white,
                fontSize: 10,
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        );
      },
    ),
  ],
)
```

---

## üì¶ FEATURE 2: NOTIFICATION PREFERENCES

### Existing Screen
**File:** `lib/features/profile/presentation/pages/settings.dart` (lines 79-91)

**Current State:**
- ‚úÖ "Notification Preferences" section exists
- ‚úÖ 5 toggle switches exist
- ‚ö†Ô∏è Not connected to backend

**Goal:** Connect toggles to backend API

---

### Step 2.1: Create Preferences Data Source (30 mins)

**File:** `lib/features/notification/data/datasources/notification_preferences_datasource.dart`

```dart
import 'package:dio/dio.dart';
import '../../../../core/services/auth_service.dart';

class NotificationPreferences {
  final bool orderUpdates;
  final bool scheduledOrderReminders;
  final bool disputeUpdates;
  final bool marketing;
  final bool systemNotifications;

  NotificationPreferences({
    required this.orderUpdates,
    required this.scheduledOrderReminders,
    required this.disputeUpdates,
    required this.marketing,
    required this.systemNotifications,
  });

  factory NotificationPreferences.fromJson(Map<String, dynamic> json) {
    return NotificationPreferences(
      orderUpdates: json['orderUpdates'] as bool? ?? true,
      scheduledOrderReminders: json['scheduledOrderReminders'] as bool? ?? true,
      disputeUpdates: json['disputeUpdates'] as bool? ?? true,
      marketing: json['marketing'] as bool? ?? false,
      systemNotifications: json['systemNotifications'] as bool? ?? true,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'orderUpdates': orderUpdates,
      'scheduledOrderReminders': scheduledOrderReminders,
      'disputeUpdates': disputeUpdates,
      'marketing': marketing,
      'systemNotifications': systemNotifications,
    };
  }
}

abstract class NotificationPreferencesDataSource {
  Future<NotificationPreferences> getPreferences();
  Future<NotificationPreferences> updatePreferences(NotificationPreferences prefs);
}

class NotificationPreferencesDataSourceImpl 
    implements NotificationPreferencesDataSource {
  final Dio dio;
  static const String baseUrl = 'https://nartawi.smartvillageqatar.com/api';

  NotificationPreferencesDataSourceImpl({required this.dio});

  @override
  Future<NotificationPreferences> getPreferences() async {
    try {
      final token = await AuthService.getToken();

      final response = await dio.get(
        '$baseUrl/v1/client/notifications/preferences',
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'accept': 'application/json',
          },
        ),
      );

      if (response.statusCode == 200) {
        return NotificationPreferences.fromJson(
          response.data as Map<String, dynamic>,
        );
      } else {
        throw Exception('Failed to fetch preferences');
      }
    } catch (e) {
      print('‚ùå Error fetching preferences: $e');
      rethrow;
    }
  }

  @override
  Future<NotificationPreferences> updatePreferences(
    NotificationPreferences prefs,
  ) async {
    try {
      final token = await AuthService.getToken();

      final response = await dio.put(
        '$baseUrl/v1/client/notifications/preferences',
        data: prefs.toJson(),
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'Content-Type': 'application/json',
            'accept': 'application/json',
          },
        ),
      );

      if (response.statusCode == 200) {
        return NotificationPreferences.fromJson(
          response.data as Map<String, dynamic>,
        );
      } else {
        throw Exception('Failed to update preferences');
      }
    } catch (e) {
      print('‚ùå Error updating preferences: $e');
      rethrow;
    }
  }
}
```

---

### Step 2.2: Update Existing Settings Screen (1 hour)

**File:** `lib/features/profile/presentation/pages/settings.dart`

**Add controller at top of _SettingsScreenState:**
```dart
import 'package:dio/dio.dart';
import '../../../notification/data/datasources/notification_preferences_datasource.dart';

class _SettingsScreenState extends State<SettingsScreen> {
  late NotificationPreferencesDataSourceImpl _prefsDataSource;
  
  bool _orderUpdates = true;
  bool _scheduledOrderReminders = true;
  bool _disputeUpdates = true;
  bool _marketing = false;
  bool _systemNotifications = true;
  bool _isLoadingPrefs = true;

  @override
  void initState() {
    super.initState();
    _prefsDataSource = NotificationPreferencesDataSourceImpl(dio: Dio());
    _loadPreferences();
  }

  Future<void> _loadPreferences() async {
    try {
      final prefs = await _prefsDataSource.getPreferences();
      if (mounted) {
        setState(() {
          _orderUpdates = prefs.orderUpdates;
          _scheduledOrderReminders = prefs.scheduledOrderReminders;
          _disputeUpdates = prefs.disputeUpdates;
          _marketing = prefs.marketing;
          _systemNotifications = prefs.systemNotifications;
          _isLoadingPrefs = false;
        });
      }
    } catch (e) {
      print('Error loading preferences: $e');
      setState(() => _isLoadingPrefs = false);
    }
  }

  Future<void> _updatePreferences() async {
    try {
      final prefs = NotificationPreferences(
        orderUpdates: _orderUpdates,
        scheduledOrderReminders: _scheduledOrderReminders,
        disputeUpdates: _disputeUpdates,
        marketing: _marketing,
        systemNotifications: _systemNotifications,
      );
      
      await _prefsDataSource.updatePreferences(prefs);
    } catch (e) {
      print('Error updating preferences: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to save preferences')),
      );
    }
  }
}
```

**Update existing SettingCard widgets to use state:**
```dart
// Replace lines 83-91 with:

if (_isLoadingPrefs)
  Center(child: CircularProgressIndicator())
else ...[
  SwitchListTile(
    title: Text('Order Updates'),
    subtitle: Text('Receive notifications about your order status'),
    value: _orderUpdates,
    onChanged: (value) {
      setState(() => _orderUpdates = value);
      _updatePreferences();
    },
  ),
  Divider(),
  
  SwitchListTile(
    title: Text('Scheduled Order Reminders'),
    subtitle: Text('Low balance, upcoming deliveries'),
    value: _scheduledOrderReminders,
    onChanged: (value) {
      setState(() => _scheduledOrderReminders = value);
      _updatePreferences();
    },
  ),
  Divider(),
  
  SwitchListTile(
    title: Text('Dispute Updates'),
    subtitle: Text('Dispute status changes'),
    value: _disputeUpdates,
    onChanged: (value) {
      setState(() => _disputeUpdates = value);
      _updatePreferences();
    },
  ),
  Divider(),
  
  SwitchListTile(
    title: Text('Marketing & Promotions'),
    subtitle: Text('Special offers and deals'),
    value: _marketing,
    onChanged: (value) {
      setState(() => _marketing = value);
      _updatePreferences();
    },
  ),
  Divider(),
  
  SwitchListTile(
    title: Text('System Notifications'),
    subtitle: Text('App updates, maintenance'),
    value: _systemNotifications,
    onChanged: (value) {
      setState(() => _systemNotifications = value);
      _updatePreferences();
    },
  ),
],
```

---

## üì¶ FEATURE 3: SUPPLIER REVIEWS

### Existing Implementation
**Files:**
- `lib/features/orders/presentation/widgets/review_alert_dialog.dart` - Review UI
- `lib/features/home/presentation/provider/supplier_reviews_controller.dart` - GET reviews

**Current State:**
- ‚úÖ Review dialog UI exists with star ratings
- ‚úÖ Controller fetches reviews (GET)
- ‚ö†Ô∏è No POST submission

**Goal:** Add review submission

---

### Step 3.1: Update Reviews Controller (30 mins)

**File:** `lib/features/home/presentation/provider/supplier_reviews_controller.dart`

**Add submitReview method:**
```dart
// Add at end of SupplierReviewsController class

Future<bool> submitReview({
  required int orderId,
  required int supplierId,
  required int rating,
  String? comment,
}) async {
  try {
    final token = await AuthService.getToken();
    if (token == null) {
      error = 'Authentication required';
      notifyListeners();
      return false;
    }

    final url = '$base_url/v1/client/reviews';

    final response = await dio.post(
      url,
      data: {
        'orderId': orderId,
        'supplierId': supplierId,
        'rating': rating,
        if (comment != null && comment.isNotEmpty) 'comment': comment,
      },
      options: Options(
        headers: {
          'accept': 'application/json',
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
      ),
    );

    if (response.statusCode == 201 || response.statusCode == 200) {
      debugPrint('‚úÖ Review submitted successfully');
      return true;
    } else {
      error = 'Failed to submit review (status: ${response.statusCode})';
      notifyListeners();
      return false;
    }
  } on DioException catch (e) {
    final d = e.response?.data;
    String msg = 'Failed to submit review';
    if (d is Map && d['title'] != null) msg = d['title'].toString();
    else if (d is Map && d['message'] != null) msg = d['message'].toString();
    else if (e.message != null) msg = e.message!;
    error = msg;
    notifyListeners();
    return false;
  } catch (e) {
    error = 'An unexpected error occurred: $e';
    notifyListeners();
    return false;
  }
}
```

---

### Step 3.2: Update Review Dialog (1 hour)

**File:** `lib/features/orders/presentation/widgets/review_alert_dialog.dart`

**Update widget to accept order/supplier data and submit:**

```dart
import 'package:dio/dio.dart';
import '../../../home/presentation/provider/supplier_reviews_controller.dart';

class ReviewAlertDialog extends StatefulWidget {
  final int orderId;
  final int supplierId;
  final String supplierName;
  
  const ReviewAlertDialog({
    super.key,
    required this.orderId,
    required this.supplierId,
    required this.supplierName,
  });

  @override
  State<ReviewAlertDialog> createState() => _ReviewAlertDialogState();
}

class _ReviewAlertDialogState extends State<ReviewAlertDialog> {
  late SupplierReviewsController _controller;
  
  int _orderRating = 0;
  int _sellerRating = 0;
  int _deliveryRating = 0;
  
  final TextEditingController _orderCommentController = TextEditingController();
  final TextEditingController _sellerCommentController = TextEditingController();
  final TextEditingController _deliveryCommentController = TextEditingController();
  
  bool _isSubmitting = false;

  @override
  void initState() {
    super.initState();
    _controller = SupplierReviewsController(dio: Dio());
  }

  @override
  void dispose() {
    _orderCommentController.dispose();
    _sellerCommentController.dispose();
    _deliveryCommentController.dispose();
    super.dispose();
  }

  Future<void> _submitReview() async {
    // Validate
    if (_sellerRating == 0) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Please rate the seller'),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    setState(() => _isSubmitting = true);

    // Calculate average rating
    final avgRating = ((_orderRating + _sellerRating + _deliveryRating) / 3).round();
    
    // Combine comments
    final combinedComment = [
      if (_orderCommentController.text.isNotEmpty) 
        'Order: ${_orderCommentController.text}',
      if (_sellerCommentController.text.isNotEmpty) 
        'Seller: ${_sellerCommentController.text}',
      if (_deliveryCommentController.text.isNotEmpty) 
        'Delivery: ${_deliveryCommentController.text}',
    ].join(' | ');

    final success = await _controller.submitReview(
      orderId: widget.orderId,
      supplierId: widget.supplierId,
      rating: avgRating,
      comment: combinedComment.isNotEmpty ? combinedComment : null,
    );

    setState(() => _isSubmitting = false);

    if (success) {
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Thank you for your review!'),
          backgroundColor: Colors.green,
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(_controller.error ?? 'Failed to submit review'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    final screenWidth = MediaQuery.of(context).size.width;
    
    return Dialog(
      backgroundColor: AppColors.backgroundAlert,
      insetPadding: EdgeInsets.all(16),
      child: SizedBox(
        width: MediaQuery.of(context).size.width * 0.94,
        height: MediaQuery.of(context).size.height * 0.7,
        child: Padding(
          padding: EdgeInsets.symmetric(
            vertical: screenHeight * .02,
            horizontal: screenWidth * .05,
          ),
          child: SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      'Leave Review',
                      style: TextStyle(
                        fontWeight: FontWeight.w700,
                        fontSize: screenWidth * .04,
                      ),
                    ),
                    IconButton(
                      onPressed: () => Navigator.pop(context),
                      icon: Icon(
                        Icons.close,
                        size: screenWidth * .05,
                        color: AppColors.greyDarktextIntExtFieldAndIconsHome,
                      ),
                    ),
                  ],
                ),
                SizedBox(height: screenHeight * .01),
                
                Text(
                  widget.supplierName,
                  style: TextStyle(
                    fontSize: screenWidth * .035,
                    color: Colors.grey,
                  ),
                ),
                SizedBox(height: screenHeight * .02),

                _buildRatingSection(
                  'Order Experience',
                  _orderRating,
                  (rating) => setState(() => _orderRating = rating),
                  _orderCommentController,
                  screenWidth,
                  screenHeight,
                ),
                
                _buildRatingSection(
                  'Seller Experience',
                  _sellerRating,
                  (rating) => setState(() => _sellerRating = rating),
                  _sellerCommentController,
                  screenWidth,
                  screenHeight,
                ),
                
                _buildRatingSection(
                  'Delivery Experience',
                  _deliveryRating,
                  (rating) => setState(() => _deliveryRating = rating),
                  _deliveryCommentController,
                  screenWidth,
                  screenHeight,
                ),

                SizedBox(height: screenHeight * .02),

                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: _isSubmitting ? null : () => Navigator.pop(context),
                        child: Text('Cancel'),
                      ),
                    ),
                    SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: _isSubmitting ? null : _submitReview,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppColors.primary,
                        ),
                        child: _isSubmitting
                            ? SizedBox(
                                height: 20,
                                width: 20,
                                child: CircularProgressIndicator(
                                  color: Colors.white,
                                  strokeWidth: 2,
                                ),
                              )
                            : Text(
                                'Leave Review',
                                style: TextStyle(color: Colors.white),
                              ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildRatingSection(
    String title,
    int rating,
    Function(int) onRatingChanged,
    TextEditingController commentController,
    double screenWidth,
    double screenHeight,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: TextStyle(
            fontWeight: FontWeight.w700,
            fontSize: screenWidth * .04,
          ),
        ),
        SizedBox(height: 8),
        RatingBar(
          initialRating: rating.toDouble(),
          maxRating: 5,
          glow: false,
          allowHalfRating: false,
          itemSize: screenWidth * .07,
          itemPadding: EdgeInsets.symmetric(horizontal: screenWidth * .01),
          ratingWidget: RatingWidget(
            full: Icon(Icons.star, color: Colors.amber),
            half: Icon(Icons.star_half, color: Colors.amber),
            empty: Icon(Icons.star_border, color: Colors.amber),
          ),
          onRatingUpdate: (value) => onRatingChanged(value.toInt()),
        ),
        SizedBox(height: 8),
        TextField(
          controller: commentController,
          decoration: InputDecoration(
            hintText: 'Write your review here (optional)',
            border: OutlineInputBorder(),
            contentPadding: EdgeInsets.all(12),
          ),
          maxLines: 2,
          maxLength: 300,
        ),
        SizedBox(height: screenHeight * .02),
      ],
    );
  }
}
```

---

### Step 3.3: Trigger Review Dialog from Orders (30 mins)

**File:** Update order details screen or delivered order UI

**Add button to delivered orders:**
```dart
// In order details, if order status is DELIVERED and not reviewed:
if (order.status == 'DELIVERED' && !order.hasReview)
  ElevatedButton(
    onPressed: () {
      showDialog(
        context: context,
        builder: (_) => ReviewAlertDialog(
          orderId: order.id,
          supplierId: order.supplierId,
          supplierName: order.supplierName,
        ),
      );
    },
    child: Text('Leave Review'),
  ),
```

---

## üì¶ FEATURE 4: FCM PUSH NOTIFICATIONS

### Step 4.1: Add Firebase Dependencies

**File:** `pubspec.yaml`

```yaml
dependencies:
  firebase_core: ^2.24.0
  firebase_messaging: ^14.7.6
  flutter_local_notifications: ^16.3.0
  device_info_plus: ^9.1.1
```

---

### Step 4.2: Create FCM Service (2 hours)

**File:** `lib/core/services/fcm_service.dart`

```dart
import 'dart:io';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:dio/dio.dart';
import '../../features/notification/presentation/provider/notification_controller.dart';

class FCMService {
  static final FCMService _instance = FCMService._internal();
  factory FCMService() => _instance;
  FCMService._internal();

  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  final FlutterLocalNotificationsPlugin _localNotifications = 
      FlutterLocalNotificationsPlugin();
  
  NotificationController? _notificationController;

  Future<void> initialize(NotificationController controller) async {
    _notificationController = controller;

    // Request permission
    NotificationSettings settings = await _messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
      provisional: false,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      print('‚úÖ FCM permission granted');
      
      // Initialize local notifications
      await _initializeLocalNotifications();
      
      // Get and register FCM token
      final token = await _messaging.getToken();
      if (token != null) {
        await _registerToken(token);
      }

      // Listen for token refresh
      _messaging.onTokenRefresh.listen(_registerToken);

      // Handle foreground messages
      FirebaseMessaging.onMessage.listen(_handleForegroundMessage);

      // Handle background message tap
      FirebaseMessaging.onMessageOpenedApp.listen(_handleBackgroundMessageTap);

      // Check if app opened from notification
      final initialMessage = await _messaging.getInitialMessage();
      if (initialMessage != null) {
        _handleBackgroundMessageTap(initialMessage);
      }
    } else {
      print('‚ùå FCM permission denied');
    }
  }

  Future<void> _initializeLocalNotifications() async {
    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosSettings = DarwinInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );
    
    const settings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );

    await _localNotifications.initialize(
      settings,
      onDidReceiveNotificationResponse: _handleLocalNotificationTap,
    );
  }

  Future<void> _registerToken(String token) async {
    try {
      String deviceId = 'unknown';
      String deviceType = Platform.isIOS ? 'iOS' : 'Android';

      if (Platform.isAndroid) {
        final androidInfo = await DeviceInfoPlugin().androidInfo;
        deviceId = androidInfo.id;
      } else if (Platform.isIOS) {
        final iosInfo = await DeviceInfoPlugin().iosInfo;
        deviceId = iosInfo.identifierForVendor ?? 'unknown';
      }

      if (_notificationController != null) {
        await _notificationController!.registerFCMToken(
          token: token,
          deviceType: deviceType,
          deviceId: deviceId,
        );
        print('‚úÖ FCM token registered: ${token.substring(0, 20)}...');
      }
    } catch (e) {
      print('‚ùå Failed to register FCM token: $e');
    }
  }

  void _handleForegroundMessage(RemoteMessage message) {
    print('üì© Foreground message: ${message.notification?.title}');
    
    // Show local notification
    _showLocalNotification(message);
    
    // Refresh notifications list
    _notificationController?.refreshUnreadCount();
  }

  void _handleBackgroundMessageTap(RemoteMessage message) {
    print('üîî Background message tapped: ${message.notification?.title}');
    
    // Handle navigation based on data
    final data = message.data;
    if (data['relatedEntityType'] != null && data['relatedEntityId'] != null) {
      // Add navigation logic here
      // Navigator.push(...) to relevant screen
    }
  }

  void _handleLocalNotificationTap(NotificationResponse response) {
    print('üîî Local notification tapped: ${response.payload}');
    // Handle tap if needed
  }

  Future<void> _showLocalNotification(RemoteMessage message) async {
    final notification = message.notification;
    if (notification == null) return;

    const androidDetails = AndroidNotificationDetails(
      'default_channel',
      'Default Notifications',
      channelDescription: 'Default notification channel',
      importance: Importance.high,
      priority: Priority.high,
      icon: '@mipmap/ic_launcher',
    );

    const iosDetails = DarwinNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
    );

    const details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );

    await _localNotifications.show(
      message.hashCode,
      notification.title,
      notification.body,
      details,
      payload: message.data.toString(),
    );
  }
}

// Background message handler (must be top-level function)
@pragma('vm:entry-point')
Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  print('üì© Background message: ${message.notification?.title}');
}
```

---

### Step 4.3: Initialize FCM in main.dart

**File:** `lib/main.dart`

```dart
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'core/services/fcm_service.dart';
import 'features/notification/presentation/provider/notification_controller.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize Firebase
  await Firebase.initializeApp();
  
  // Set background message handler
  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);
  
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // ... existing app setup
    
    // Initialize FCM after login
    final notificationController = NotificationController(dio: Dio());
    FCMService().initialize(notificationController);
    
    // ... rest of app
  }
}
```

---

## ‚úÖ TESTING CHECKLIST

### Notifications
- [ ] App fetches notifications from API on launch
- [ ] Tabs show correct filtered notifications (All, New, Read, Orders, Coupons, Promos)
- [ ] Pull-to-refresh reloads notifications
- [ ] Pagination loads more on scroll
- [ ] Tap notification marks it as read
- [ ] Unread badge shows in app bar
- [ ] "Mark all read" button works
- [ ] Notification icon colors match type
- [ ] Time ago displays correctly
- [ ] Empty state shows when no notifications

### Preferences
- [ ] Settings screen loads current preferences from API
- [ ] Each toggle switch works
- [ ] Changes save immediately to backend
- [ ] Preferences persist after app restart
- [ ] Loading indicator shows while fetching

### Reviews
- [ ] Review dialog opens from delivered orders
- [ ] Can rate 1-5 stars for each category
- [ ] Comment is optional
- [ ] Submit button disabled until at least seller rating given
- [ ] Review submits successfully to backend
- [ ] Success message shows after submission
- [ ] Dialog closes after successful submission
- [ ] Error message shows if submission fails

### FCM
- [ ] FCM token registers on app launch
- [ ] Foreground notifications show as local notifications
- [ ] Background notifications appear in notification tray
- [ ] Tapping notification opens app
- [ ] Unread count refreshes when notification received
- [ ] Token re-registers on refresh

---

## üìä IMPLEMENTATION SUMMARY

| Feature | Files Modified | Files Created | Time |
|---------|---------------|---------------|------|
| Notifications API | 2 | 3 | 3 hours |
| Preferences API | 1 | 1 | 1 hour |
| Reviews API | 2 | 0 | 1 hour |
| FCM Integration | 1 | 1 | 2 hours |
| **Total** | **6 modified** | **5 created** | **7 hours** |

---

## üéØ ACCEPTANCE CRITERIA

- [x] No new screens created
- [x] All APIs integrated into existing UI
- [x] Existing notification screen uses backend data
- [x] Existing preferences toggles connected to API
- [x] Existing review dialog submits to backend
- [x] FCM push notifications working
- [x] Design constraints respected

---

## üöÄ READY TO START

**Status:** ‚úÖ **CLEAR TO START - No blockers**

- ‚úÖ Backend APIs confirmed ready
- ‚úÖ No new screens required
- ‚úÖ All existing UI identified
- ‚úÖ Implementation plan complete

**Estimated completion:** 7 hours (1 developer day)

---

**END OF REVISED M1.0.4 GUIDE**
