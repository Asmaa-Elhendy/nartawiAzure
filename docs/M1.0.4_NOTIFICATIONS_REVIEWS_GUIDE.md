# M1.0.4 - Notifications & Reviews Implementation Guide

**Release:** M1.0.4 - Notifications, Reviews, Polish  
**Status:** ðŸŸ¢ Ready - All APIs Confirmed  
**Duration:** 1 week  
**Start:** After M1.0.3 completion  
**Target:** February 13, 2026

---

## ðŸ“‹ FEATURES OVERVIEW

1. **Notifications System** - List, read, unread count, FCM push
2. **Notification Preferences** - Toggle notification types
3. **Supplier Reviews** - Rate suppliers after order delivery
4. **Favorites Verification** - Test existing implementation

---

## ðŸ”” FEATURE 1: NOTIFICATIONS SYSTEM

### API Endpoints

#### 1.1 Get Notifications List
**Endpoint:** `GET /api/v1/client/notifications`

**Query Parameters:**
```
pageNumber: int (default 1)
pageSize: int (default 20, max 100)
isRead: boolean (optional - filter read/unread)
```

**Response:**
```json
{
  "items": [
    {
      "id": 123,
      "title": "Order Delivered",
      "message": "Your order #ORD-456 has been delivered successfully",
      "type": "ORDER_UPDATE",
      "isRead": false,
      "relatedEntityType": "Order",
      "relatedEntityId": 456,
      "createdAt": "2026-01-12T14:30:00Z",
      "readAt": null
    },
    {
      "id": 122,
      "title": "Low Coupon Balance",
      "message": "You have only 2 coupons remaining. Refill your wallet now!",
      "type": "SCHEDULED_ORDER_REMINDER",
      "isRead": true,
      "relatedEntityType": "ScheduledOrder",
      "relatedEntityId": 45,
      "createdAt": "2026-01-11T09:00:00Z",
      "readAt": "2026-01-11T10:15:00Z"
    }
  ],
  "pagination": {
    "currentPage": 1,
    "totalPages": 5,
    "totalCount": 87,
    "hasNextPage": true
  }
}
```

**Notification Types:**
- `ORDER_UPDATE` - Order status changes
- `SCHEDULED_ORDER_REMINDER` - Low balance, next delivery
- `DISPUTE_UPDATE` - Dispute status changes
- `MARKETING` - Promotions, offers
- `SYSTEM` - App updates, maintenance

#### 1.2 Get Unread Count
**Endpoint:** `GET /api/v1/client/notifications/unread-count`

**Response:**
```json
{
  "unreadCount": 5
}
```

#### 1.3 Mark as Read
**Endpoint:** `POST /api/v1/client/notifications/{id}/read`

**Response:** 200 OK (empty body)

#### 1.4 Mark All as Read
**Endpoint:** `POST /api/v1/client/notifications/read-all`

**Response:** 200 OK
```json
{
  "markedCount": 5
}
```

#### 1.5 Register FCM Token
**Endpoint:** `POST /api/v1/client/notifications/push-tokens`

**Request:**
```json
{
  "token": "fcm-token-here",
  "deviceType": "Android",
  "deviceId": "unique-device-id"
}
```

**Response:** 200 OK

---

## ðŸ’» IMPLEMENTATION: NOTIFICATIONS

### Step 1: Create Notification Model (30 mins)

**File:** `lib/features/notifications/data/models/notification_model.dart`

```dart
class NotificationModel {
  final int id;
  final String title;
  final String message;
  final String type;
  final bool isRead;
  final String? relatedEntityType;
  final int? relatedEntityId;
  final DateTime createdAt;
  final DateTime? readAt;

  NotificationModel({
    required this.id,
    required this.title,
    required this.message,
    required this.type,
    required this.isRead,
    this.relatedEntityType,
    this.relatedEntityId,
    required this.createdAt,
    this.readAt,
  });

  factory NotificationModel.fromJson(Map<String, dynamic> json) {
    return NotificationModel(
      id: json['id'] as int,
      title: json['title'] as String,
      message: json['message'] as String,
      type: json['type'] as String,
      isRead: json['isRead'] as bool,
      relatedEntityType: json['relatedEntityType'] as String?,
      relatedEntityId: json['relatedEntityId'] as int?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      readAt: json['readAt'] != null 
          ? DateTime.parse(json['readAt'] as String) 
          : null,
    );
  }

  IconData get icon {
    switch (type) {
      case 'ORDER_UPDATE':
        return Icons.shopping_bag;
      case 'SCHEDULED_ORDER_REMINDER':
        return Icons.schedule;
      case 'DISPUTE_UPDATE':
        return Icons.report_problem;
      case 'MARKETING':
        return Icons.local_offer;
      case 'SYSTEM':
        return Icons.info;
      default:
        return Icons.notifications;
    }
  }

  Color get iconColor {
    switch (type) {
      case 'ORDER_UPDATE':
        return Colors.blue;
      case 'SCHEDULED_ORDER_REMINDER':
        return Colors.orange;
      case 'DISPUTE_UPDATE':
        return Colors.red;
      case 'MARKETING':
        return Colors.green;
      case 'SYSTEM':
        return Colors.grey;
      default:
        return Colors.grey;
    }
  }

  String get timeAgo {
    final now = DateTime.now();
    final difference = now.difference(createdAt);

    if (difference.inDays > 7) {
      return DateFormat('MMM d, yyyy').format(createdAt);
    } else if (difference.inDays > 0) {
      return '${difference.inDays} day${difference.inDays > 1 ? 's' : ''} ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours} hour${difference.inHours > 1 ? 's' : ''} ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes} min ago';
    } else {
      return 'Just now';
    }
  }
}
```

### Step 2: Create Notifications Screen (2 hours)

**File:** `lib/features/notifications/presentation/screens/notifications_screen.dart`

```dart
class NotificationsScreen extends StatefulWidget {
  @override
  _NotificationsScreenState createState() => _NotificationsScreenState();
}

class _NotificationsScreenState extends State<NotificationsScreen> {
  final NotificationController _controller = Get.find<NotificationController>();
  final ScrollController _scrollController = ScrollController();
  
  int _currentPage = 1;
  bool _isLoadingMore = false;

  @override
  void initState() {
    super.initState();
    _fetchNotifications();
    _scrollController.addListener(_onScroll);
    
    // Poll for new notifications every 60 seconds
    Timer.periodic(Duration(seconds: 60), (timer) {
      if (mounted) {
        _controller.refreshUnreadCount();
      } else {
        timer.cancel();
      }
    });
  }

  Future<void> _fetchNotifications({bool loadMore = false}) async {
    if (loadMore) {
      setState(() {
        _isLoadingMore = true;
        _currentPage++;
      });
    } else {
      _currentPage = 1;
    }

    await _controller.fetchNotifications(pageNumber: _currentPage);

    if (loadMore) {
      setState(() => _isLoadingMore = false);
    }
  }

  void _onScroll() {
    if (_scrollController.position.pixels >= 
        _scrollController.position.maxScrollExtent - 200) {
      if (!_isLoadingMore && _controller.hasMoreNotifications.value) {
        _fetchNotifications(loadMore: true);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Notifications'),
        actions: [
          Obx(() {
            if (_controller.notifications.isEmpty) return SizedBox.shrink();
            
            return TextButton(
              onPressed: _controller.markAllAsRead,
              child: Text(
                'Mark all read',
                style: TextStyle(color: Colors.white),
              ),
            );
          }),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () => _fetchNotifications(),
        child: Obx(() {
          if (_controller.isLoading.value && _currentPage == 1) {
            return Center(child: CircularProgressIndicator());
          }

          if (_controller.notifications.isEmpty) {
            return _buildEmptyState();
          }

          return ListView.separated(
            controller: _scrollController,
            padding: EdgeInsets.symmetric(vertical: 8),
            itemCount: _controller.notifications.length + (_isLoadingMore ? 1 : 0),
            separatorBuilder: (context, index) => Divider(height: 1),
            itemBuilder: (context, index) {
              if (index >= _controller.notifications.length) {
                return Center(
                  padding: EdgeInsets.all(16),
                  child: CircularProgressIndicator(),
                );
              }

              final notification = _controller.notifications[index];
              return _buildNotificationTile(notification);
            },
          );
        }),
      ),
    );
  }

  Widget _buildNotificationTile(NotificationModel notification) {
    return Dismissible(
      key: Key('notification-${notification.id}'),
      direction: DismissDirection.endToStart,
      background: Container(
        color: Colors.red,
        alignment: Alignment.centerRight,
        padding: EdgeInsets.only(right: 20),
        child: Icon(Icons.delete, color: Colors.white),
      ),
      confirmDismiss: (direction) async {
        // Could add delete endpoint here if backend supports it
        return false;
      },
      child: InkWell(
        onTap: () => _handleNotificationTap(notification),
        child: Container(
          color: notification.isRead 
              ? Colors.white 
              : Colors.blue.withOpacity(0.05),
          padding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Icon
              Container(
                width: 40,
                height: 40,
                decoration: BoxDecoration(
                  color: notification.iconColor.withOpacity(0.1),
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  notification.icon,
                  color: notification.iconColor,
                  size: 20,
                ),
              ),
              SizedBox(width: 12),
              
              // Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            notification.title,
                            style: TextStyle(
                              fontWeight: notification.isRead 
                                  ? FontWeight.normal 
                                  : FontWeight.bold,
                              fontSize: 15,
                            ),
                          ),
                        ),
                        if (!notification.isRead)
                          Container(
                            width: 8,
                            height: 8,
                            decoration: BoxDecoration(
                              color: Colors.blue,
                              shape: BoxShape.circle,
                            ),
                          ),
                      ],
                    ),
                    SizedBox(height: 4),
                    Text(
                      notification.message,
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.grey[700],
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    SizedBox(height: 4),
                    Text(
                      notification.timeAgo,
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.notifications_none,
            size: 80,
            color: Colors.grey,
          ),
          SizedBox(height: 16),
          Text(
            'No notifications',
            style: TextStyle(fontSize: 18, color: Colors.grey),
          ),
        ],
      ),
    );
  }

  Future<void> _handleNotificationTap(NotificationModel notification) async {
    // Mark as read
    if (!notification.isRead) {
      await _controller.markAsRead(notification.id);
    }

    // Navigate based on related entity
    if (notification.relatedEntityType != null && 
        notification.relatedEntityId != null) {
      switch (notification.relatedEntityType) {
        case 'Order':
          Get.to(() => OrderDetailsScreen(
            orderId: notification.relatedEntityId!,
          ));
          break;
        case 'ScheduledOrder':
          Get.to(() => ScheduledOrdersScreen());
          break;
        case 'Dispute':
          Get.to(() => DisputeDetailsScreen(
            disputeId: notification.relatedEntityId!,
          ));
          break;
      }
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }
}
```

### Step 3: Add Unread Badge to App Bar (30 mins)

**File:** Update main app bar or navigation

```dart
// In app bar
actions: [
  Stack(
    children: [
      IconButton(
        icon: Icon(Icons.notifications),
        onPressed: () => Get.to(() => NotificationsScreen()),
      ),
      Obx(() {
        final count = Get.find<NotificationController>().unreadCount.value;
        if (count == 0) return SizedBox.shrink();
        
        return Positioned(
          right: 8,
          top: 8,
          child: Container(
            padding: EdgeInsets.all(4),
            decoration: BoxDecoration(
              color: Colors.red,
              shape: BoxShape.circle,
            ),
            constraints: BoxConstraints(
              minWidth: 16,
              minHeight: 16,
            ),
            child: Text(
              count > 99 ? '99+' : count.toString(),
              style: TextStyle(
                color: Colors.white,
                fontSize: 10,
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        );
      }),
    ],
  ),
]
```

### Step 4: Implement FCM Push Notifications (2 hours)

**File:** `lib/core/services/fcm_service.dart`

```dart
class FCMService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  final NotificationController _notificationController = Get.find();

  Future<void> initialize() async {
    // Request permission
    NotificationSettings settings = await _messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      print('User granted notification permission');
      
      // Get FCM token
      final token = await _messaging.getToken();
      if (token != null) {
        await _registerToken(token);
      }

      // Listen for token refresh
      _messaging.onTokenRefresh.listen(_registerToken);

      // Handle foreground messages
      FirebaseMessaging.onMessage.listen(_handleForegroundMessage);

      // Handle background messages
      FirebaseMessaging.onMessageOpenedApp.listen(_handleBackgroundMessage);
    }
  }

  Future<void> _registerToken(String token) async {
    try {
      final deviceInfo = await DeviceInfoPlugin().androidInfo;
      
      await Dio().post(
        '${AppConstants.baseUrl}/v1/client/notifications/push-tokens',
        data: {
          'token': token,
          'deviceType': Platform.isIOS ? 'iOS' : 'Android',
          'deviceId': deviceInfo.id,
        },
        options: Options(
          headers: {
            'Authorization': 'Bearer ${await Get.find<AuthService>().getAccessToken()}',
          },
        ),
      );
      
      print('FCM token registered: $token');
    } catch (e) {
      print('Failed to register FCM token: $e');
    }
  }

  void _handleForegroundMessage(RemoteMessage message) {
    print('Foreground message: ${message.notification?.title}');
    
    // Show local notification
    _showLocalNotification(message);
    
    // Refresh notifications list
    _notificationController.refreshUnreadCount();
  }

  void _handleBackgroundMessage(RemoteMessage message) {
    print('Background message opened: ${message.notification?.title}');
    
    // Navigate to relevant screen based on data
    if (message.data['relatedEntityType'] != null) {
      // Handle navigation
    }
  }

  void _showLocalNotification(RemoteMessage message) {
    // Use flutter_local_notifications to show in-app notification
  }
}
```

---

## âš™ï¸ FEATURE 2: NOTIFICATION PREFERENCES

### API Endpoints

#### Get Preferences
**Endpoint:** `GET /api/v1/client/notifications/preferences`

**Response:**
```json
{
  "orderUpdates": true,
  "scheduledOrderReminders": true,
  "disputeUpdates": true,
  "marketing": false,
  "systemNotifications": true
}
```

#### Update Preferences
**Endpoint:** `PUT /api/v1/client/notifications/preferences`

**Request:**
```json
{
  "orderUpdates": true,
  "scheduledOrderReminders": true,
  "disputeUpdates": true,
  "marketing": false,
  "systemNotifications": true
}
```

**Response:** Same as request (200 OK)

### Implementation (1 hour)

**File:** `lib/features/notifications/presentation/screens/notification_preferences_screen.dart`

```dart
class NotificationPreferencesScreen extends StatefulWidget {
  @override
  _NotificationPreferencesScreenState createState() => _NotificationPreferencesScreenState();
}

class _NotificationPreferencesScreenState extends State<NotificationPreferencesScreen> {
  final _controller = Get.find<NotificationController>();
  
  bool _orderUpdates = true;
  bool _scheduledOrderReminders = true;
  bool _disputeUpdates = true;
  bool _marketing = false;
  bool _systemNotifications = true;

  @override
  void initState() {
    super.initState();
    _loadPreferences();
  }

  Future<void> _loadPreferences() async {
    final prefs = await _controller.getPreferences();
    setState(() {
      _orderUpdates = prefs.orderUpdates;
      _scheduledOrderReminders = prefs.scheduledOrderReminders;
      _disputeUpdates = prefs.disputeUpdates;
      _marketing = prefs.marketing;
      _systemNotifications = prefs.systemNotifications;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Notification Preferences'),
      ),
      body: ListView(
        children: [
          SwitchListTile(
            title: Text('Order Updates'),
            subtitle: Text('Status changes, delivery updates'),
            value: _orderUpdates,
            onChanged: (value) {
              setState(() => _orderUpdates = value);
              _savePreferences();
            },
          ),
          Divider(),
          SwitchListTile(
            title: Text('Scheduled Order Reminders'),
            subtitle: Text('Low balance, upcoming deliveries'),
            value: _scheduledOrderReminders,
            onChanged: (value) {
              setState(() => _scheduledOrderReminders = value);
              _savePreferences();
            },
          ),
          Divider(),
          SwitchListTile(
            title: Text('Dispute Updates'),
            subtitle: Text('Dispute status changes'),
            value: _disputeUpdates,
            onChanged: (value) {
              setState(() => _disputeUpdates = value);
              _savePreferences();
            },
          ),
          Divider(),
          SwitchListTile(
            title: Text('Marketing & Promotions'),
            subtitle: Text('Special offers and deals'),
            value: _marketing,
            onChanged: (value) {
              setState(() => _marketing = value);
              _savePreferences();
            },
          ),
          Divider(),
          SwitchListTile(
            title: Text('System Notifications'),
            subtitle: Text('App updates, maintenance'),
            value: _systemNotifications,
            onChanged: (value) {
              setState(() => _systemNotifications = value);
              _savePreferences();
            },
          ),
        ],
      ),
    );
  }

  Future<void> _savePreferences() async {
    await _controller.updatePreferences(
      orderUpdates: _orderUpdates,
      scheduledOrderReminders: _scheduledOrderReminders,
      disputeUpdates: _disputeUpdates,
      marketing: _marketing,
      systemNotifications: _systemNotifications,
    );
  }
}
```

---

## â­ FEATURE 3: SUPPLIER REVIEWS

### API Endpoints

#### Get Supplier Reviews
**Endpoint:** `GET /api/v1/client/reviews?supplierId={id}&pageNumber=1&pageSize=20`

**Response:**
```json
{
  "items": [
    {
      "id": 78,
      "supplierId": 1,
      "supplierName": "Rayyan Water Company",
      "orderId": 456,
      "rating": 5,
      "comment": "Excellent service! Always on time.",
      "customerName": "Ahmed M.",
      "createdAt": "2026-01-10T15:00:00Z"
    }
  ],
  "pagination": {
    "currentPage": 1,
    "totalPages": 3,
    "totalCount": 42,
    "hasNextPage": true
  },
  "averageRating": 4.7,
  "totalReviews": 42
}
```

#### Submit Review
**Endpoint:** `POST /api/v1/client/reviews`

**Request:**
```json
{
  "orderId": 456,
  "supplierId": 1,
  "rating": 5,
  "comment": "Excellent service! Always on time."
}
```

**Business Rules:**
- Can only review DELIVERED orders
- One review per order
- Rating: 1-5 stars (required)
- Comment: Optional, max 1000 chars
- Reviews are for SUPPLIERS, not products

**Response:** 201 Created (same structure as GET item)

### Implementation (2 hours)

**File:** `lib/features/reviews/presentation/screens/submit_review_screen.dart`

```dart
class SubmitReviewScreen extends StatefulWidget {
  final int orderId;
  final int supplierId;
  final String supplierName;

  const SubmitReviewScreen({
    required this.orderId,
    required this.supplierId,
    required this.supplierName,
  });

  @override
  _SubmitReviewScreenState createState() => _SubmitReviewScreenState();
}

class _SubmitReviewScreenState extends State<SubmitReviewScreen> {
  int _rating = 0;
  final _commentController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Rate Supplier'),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              widget.supplierName,
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            Text(
              'Order #${widget.orderId}',
              style: TextStyle(color: Colors.grey),
            ),
            SizedBox(height: 32),
            
            // Star Rating
            Center(
              child: Column(
                children: [
                  Text(
                    'How would you rate this supplier?',
                    style: TextStyle(fontSize: 16),
                  ),
                  SizedBox(height: 16),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: List.generate(5, (index) {
                      return IconButton(
                        icon: Icon(
                          index < _rating ? Icons.star : Icons.star_border,
                          size: 40,
                          color: Colors.amber,
                        ),
                        onPressed: () {
                          setState(() => _rating = index + 1);
                        },
                      );
                    }),
                  ),
                  if (_rating > 0)
                    Text(
                      _getRatingText(),
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: AppColors.primary,
                      ),
                    ),
                ],
              ),
            ),
            
            SizedBox(height: 32),
            
            // Comment
            TextField(
              controller: _commentController,
              decoration: InputDecoration(
                labelText: 'Your Review (Optional)',
                hintText: 'Share your experience...',
                border: OutlineInputBorder(),
              ),
              maxLines: 5,
              maxLength: 1000,
            ),
            
            SizedBox(height: 32),
            
            // Submit Button
            SizedBox(
              width: double.infinity,
              height: 48,
              child: ElevatedButton(
                onPressed: _rating > 0 ? _submitReview : null,
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppColors.primary,
                ),
                child: Text(
                  'Submit Review',
                  style: TextStyle(color: Colors.white, fontSize: 16),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _getRatingText() {
    switch (_rating) {
      case 1: return 'Poor';
      case 2: return 'Fair';
      case 3: return 'Good';
      case 4: return 'Very Good';
      case 5: return 'Excellent';
      default: return '';
    }
  }

  Future<void> _submitReview() async {
    try {
      await Get.find<ReviewController>().submitReview(
        orderId: widget.orderId,
        supplierId: widget.supplierId,
        rating: _rating,
        comment: _commentController.text.trim(),
      );

      Get.back();
      Get.snackbar(
        'Success',
        'Thank you for your review!',
        backgroundColor: Colors.green,
        colorText: Colors.white,
      );
    } catch (e) {
      Get.snackbar(
        'Error',
        'Failed to submit review: $e',
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
    }
  }

  @override
  void dispose() {
    _commentController.dispose();
    super.dispose();
  }
}
```

---

## âœ… ACCEPTANCE CRITERIA

### Notifications Complete When:
- [ ] Notifications list displays all types
- [ ] Unread badge shown in app bar
- [ ] Mark as read on tap
- [ ] Mark all as read functionality
- [ ] Pagination loads more
- [ ] Pull to refresh works
- [ ] FCM push tokens registered
- [ ] Foreground notifications shown
- [ ] Background notifications open app
- [ ] Polling every 60 seconds

### Preferences Complete When:
- [ ] All preference toggles work
- [ ] Changes saved immediately
- [ ] Preferences persist on app restart
- [ ] UI reflects current settings

### Reviews Complete When:
- [ ] Can submit review after delivery
- [ ] Star rating 1-5 required
- [ ] Comment optional
- [ ] One review per order enforced
- [ ] Reviews list shows for supplier
- [ ] Average rating calculated

---

**END OF M1.0.4 GUIDE**
