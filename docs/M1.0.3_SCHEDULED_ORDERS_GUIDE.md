# M1.0.3 - Scheduled Orders Implementation Guide

**Release:** M1.0.3 - Scheduled Orders (Full CRUD)  
**Status:** üü° Partial Ready (CREATE/READ/RESCHEDULE ready, UPDATE/DELETE in 3 days)  
**Duration:** 2 weeks  
**Start:** +3 days from M1.0.2 completion  
**Target:** February 6, 2026

---

## ‚ö†Ô∏è CRITICAL BLOCKER INFORMATION

**UPDATE and DELETE endpoints are in testing** - Backend team completing QA  
**Estimated Ready:** 3 days from today (January 12, 2026)

### What CAN Start Immediately:
- ‚úÖ CREATE scheduled orders
- ‚úÖ READ/LIST scheduled orders
- ‚úÖ RESCHEDULE next delivery

### What to WAIT For:
- ‚è∏Ô∏è UPDATE schedule (frequency, quantity, days)
- ‚è∏Ô∏è DELETE/CANCEL schedule

**Strategy:** Implement Phase 1 now, Phase 2 after 3-day wait

---

## üìã IMPLEMENTATION PHASES

### Phase 1 (Days 1-5): CREATE, READ, RESCHEDULE
**Can start immediately**

1. Create time slots constants file
2. Implement create scheduled order flow
3. Display scheduled orders list
4. Implement reschedule request
5. Update UI to show schedule details

### Phase 2 (Days 6-10): UPDATE, DELETE
**Wait for backend confirmation**

6. Implement update schedule endpoint
7. Implement delete/cancel schedule
8. Add edit schedule dialog
9. Full integration testing

---

## üìÖ TIME SLOTS HARDCODED CONSTANTS

### Step 1: Create Time Slots File (15 mins)

**New File:** `lib/core/constants/time_slots.dart`

```dart
class TimeSlot {
  final int id;
  final String nameEn;
  final String nameAr;
  final String startTime;
  final String endTime;
  final String displayTime;

  const TimeSlot({
    required this.id,
    required this.nameEn,
    required this.nameAr,
    required this.startTime,
    required this.endTime,
    required this.displayTime,
  });

  String get localizedName {
    final locale = Get.locale?.languageCode ?? 'en';
    return locale == 'ar' ? nameAr : nameEn;
  }
}

class TimeSlots {
  static const List<TimeSlot> all = [
    TimeSlot(
      id: 1,
      nameEn: 'Early Morning',
      nameAr: 'ÿßŸÑÿµÿ®ÿßÿ≠ ÿßŸÑÿ®ÿßŸÉÿ±',
      startTime: '06:00:00',
      endTime: '09:00:00',
      displayTime: '6:00 AM - 9:00 AM',
    ),
    TimeSlot(
      id: 2,
      nameEn: 'Before Noon',
      nameAr: 'ŸÇÿ®ŸÑ ÿßŸÑÿ∏Ÿáÿ±',
      startTime: '10:00:00',
      endTime: '13:00:00',
      displayTime: '10:00 AM - 1:00 PM',
    ),
    TimeSlot(
      id: 3,
      nameEn: 'Afternoon',
      nameAr: 'ÿ®ÿπÿØ ÿßŸÑÿ∏Ÿáÿ±',
      startTime: '13:00:00',
      endTime: '17:00:00',
      displayTime: '1:00 PM - 5:00 PM',
    ),
    TimeSlot(
      id: 4,
      nameEn: 'Evening',
      nameAr: 'ÿßŸÑŸÖÿ≥ÿßÿ°',
      startTime: '17:00:00',
      endTime: '21:00:00',
      displayTime: '5:00 PM - 9:00 PM',
    ),
    TimeSlot(
      id: 5,
      nameEn: 'Night',
      nameAr: 'ÿßŸÑŸÑŸäŸÑ',
      startTime: '20:00:00',
      endTime: '23:59:00',
      displayTime: '8:00 PM - 11:59 PM',
    ),
  ];

  static TimeSlot? getById(int id) {
    try {
      return all.firstWhere((slot) => slot.id == id);
    } catch (e) {
      return null;
    }
  }

  static String getDisplayTime(int id) {
    final slot = getById(id);
    return slot?.displayTime ?? 'Unknown';
  }

  static String getLocalizedName(int id) {
    final slot = getById(id);
    return slot?.localizedName ?? 'Unknown';
  }
}
```

---

## üîß PHASE 1: CREATE SCHEDULED ORDER

### API Specification

**Endpoint:** `POST /api/v1/client/scheduled-orders`

**Request Payload:**
```json
{
  "productVsid": 1,
  "bottlesPerDelivery": 2,
  "weeklyFrequency": 2,
  "notifyOnLowBalance": true,
  "schedules": [
    {
      "dayOfWeek": 0,
      "timeSlotId": 2
    },
    {
      "dayOfWeek": 3,
      "timeSlotId": 4
    }
  ]
}
```

### Field Specifications

**productVsid** (int, required)
- The product VSID to schedule deliveries for
- Must be a valid, active product
- Typically water bottles

**bottlesPerDelivery** (int, required)
- Number of bottles per delivery
- Must be > 0
- Typical values: 1-10

**weeklyFrequency** (int, required)
- How many deliveries per week
- Range: 1-7
- Must match number of schedules in array

**notifyOnLowBalance** (bool, required)
- Send notification when wallet balance insufficient
- Does NOT auto-purchase (notify only)
- Recommended: true

**schedules** (array, required)
- Length must equal weeklyFrequency
- Each entry specifies one delivery day/time

**dayOfWeek** (int, required)
- 0 = Sunday, 1 = Monday, ..., 6 = Saturday
- ‚úÖ Confirmed aligned with mobile
- Must be unique within schedules array

**timeSlotId** (int, required)
- Reference to hardcoded time slot (1-5)
- Use TimeSlots.all from constants

### Validation Rules

```dart
class ScheduledOrderValidator {
  static ValidationResult validate({
    required int productVsid,
    required int bottlesPerDelivery,
    required int weeklyFrequency,
    required List<ScheduleEntry> schedules,
  }) {
    final errors = <String>[];

    // Product VSID
    if (productVsid <= 0) {
      errors.add('Invalid product selected');
    }

    // Bottles per delivery
    if (bottlesPerDelivery <= 0) {
      errors.add('Bottles per delivery must be at least 1');
    }

    // Weekly frequency
    if (weeklyFrequency < 1 || weeklyFrequency > 7) {
      errors.add('Weekly frequency must be between 1 and 7');
    }

    // Schedules array length
    if (schedules.length != weeklyFrequency) {
      errors.add('Number of delivery days must match weekly frequency');
    }

    // Day of week uniqueness
    final days = schedules.map((s) => s.dayOfWeek).toList();
    if (days.length != days.toSet().length) {
      errors.add('Cannot schedule multiple deliveries on the same day');
    }

    // Day of week range
    for (final schedule in schedules) {
      if (schedule.dayOfWeek < 0 || schedule.dayOfWeek > 6) {
        errors.add('Invalid day of week: ${schedule.dayOfWeek}');
      }
      if (schedule.timeSlotId < 1 || schedule.timeSlotId > 5) {
        errors.add('Invalid time slot: ${schedule.timeSlotId}');
      }
    }

    return ValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
    );
  }
}
```

### Response (201 Created)

```json
{
  "id": 45,
  "scheduleNumber": "SCH-45",
  "productVsid": 1,
  "productName": "Premium Water 5 Gallon",
  "bottlesPerDelivery": 2,
  "weeklyFrequency": 2,
  "isActive": false,
  "isPaused": false,
  "statusId": 1,
  "statusName": "Pending Vendor Approval",
  "notifyOnLowBalance": true,
  "nextRun": null,
  "remainingCoupons": 0,
  "estimatedRunsRemaining": 0,
  "schedules": [
    {
      "dayOfWeek": 0,
      "dayName": "Sunday",
      "timeSlotId": 2,
      "timeSlotName": "Before Noon"
    },
    {
      "dayOfWeek": 3,
      "dayName": "Wednesday",
      "timeSlotId": 4,
      "timeSlotName": "Evening"
    }
  ],
  "createdAt": "2026-01-12T10:00:00Z"
}
```

### Key Business Logic

1. **Initial Status:** Pending Vendor Approval
   - Customer creates schedule
   - Vendor must approve before activation
   - `isActive = false` initially

2. **nextRun Calculation:**
   - NULL until vendor approves
   - After approval, calculated based on schedules
   - Next occurrence of scheduled day/time

3. **Coupon Consumption:**
   - Coupons NOT reserved for specific schedule
   - Pooled across all schedules
   - First-come-first-served from wallet

4. **Auto-Renewal Clarification:**
   - Does NOT auto-purchase bundles
   - Only sends notification when balance low
   - Schedule pauses until manual refill

---

## üíª IMPLEMENTATION: CREATE SCHEDULED ORDER

### Step 1: Create Models (1 hour)

**File:** `lib/features/scheduled_orders/data/models/scheduled_order_model.dart`

```dart
class ScheduleEntry {
  final int dayOfWeek;
  final String? dayName;
  final int timeSlotId;
  final String? timeSlotName;

  ScheduleEntry({
    required this.dayOfWeek,
    this.dayName,
    required this.timeSlotId,
    this.timeSlotName,
  });

  Map<String, dynamic> toJson() {
    return {
      'dayOfWeek': dayOfWeek,
      'timeSlotId': timeSlotId,
    };
  }

  factory ScheduleEntry.fromJson(Map<String, dynamic> json) {
    return ScheduleEntry(
      dayOfWeek: json['dayOfWeek'] as int,
      dayName: json['dayName'] as String?,
      timeSlotId: json['timeSlotId'] as int,
      timeSlotName: json['timeSlotName'] as String?,
    );
  }

  String get displayDayName {
    final days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return days[dayOfWeek];
  }
}

class ScheduledOrderModel {
  final int id;
  final String scheduleNumber;
  final int productVsid;
  final String productName;
  final int bottlesPerDelivery;
  final int weeklyFrequency;
  final bool isActive;
  final bool isPaused;
  final int statusId;
  final String statusName;
  final bool notifyOnLowBalance;
  final DateTime? nextRun;
  final int remainingCoupons;
  final int estimatedRunsRemaining;
  final List<ScheduleEntry> schedules;
  final DateTime createdAt;
  final DateTime? updatedAt;

  ScheduledOrderModel({
    required this.id,
    required this.scheduleNumber,
    required this.productVsid,
    required this.productName,
    required this.bottlesPerDelivery,
    required this.weeklyFrequency,
    required this.isActive,
    required this.isPaused,
    required this.statusId,
    required this.statusName,
    required this.notifyOnLowBalance,
    this.nextRun,
    required this.remainingCoupons,
    required this.estimatedRunsRemaining,
    required this.schedules,
    required this.createdAt,
    this.updatedAt,
  });

  factory ScheduledOrderModel.fromJson(Map<String, dynamic> json) {
    return ScheduledOrderModel(
      id: json['id'] as int,
      scheduleNumber: json['scheduleNumber'] as String,
      productVsid: json['productVsid'] as int,
      productName: json['productName'] as String,
      bottlesPerDelivery: json['bottlesPerDelivery'] as int,
      weeklyFrequency: json['weeklyFrequency'] as int,
      isActive: json['isActive'] as bool,
      isPaused: json['isPaused'] as bool,
      statusId: json['statusId'] as int,
      statusName: json['statusName'] as String,
      notifyOnLowBalance: json['notifyOnLowBalance'] as bool,
      nextRun: json['nextRun'] != null 
          ? DateTime.parse(json['nextRun'] as String) 
          : null,
      remainingCoupons: json['remainingCoupons'] as int,
      estimatedRunsRemaining: json['estimatedRunsRemaining'] as int,
      schedules: (json['schedules'] as List<dynamic>)
          .map((e) => ScheduleEntry.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: json['updatedAt'] != null 
          ? DateTime.parse(json['updatedAt'] as String) 
          : null,
    );
  }

  bool get needsApproval => statusId == 1; // Pending Vendor Approval
  bool get isApproved => statusId == 2; // Active
  bool get canReschedule => isActive && !isPaused;
  bool get hasLowBalance => estimatedRunsRemaining < 3;
  
  String get statusBadgeColor {
    switch (statusId) {
      case 1: return 'orange'; // Pending Approval
      case 2: return 'green';  // Active
      case 3: return 'red';    // Cancelled
      case 4: return 'yellow'; // Paused
      default: return 'grey';
    }
  }
}

class CreateScheduledOrderRequest {
  final int productVsid;
  final int bottlesPerDelivery;
  final int weeklyFrequency;
  final bool notifyOnLowBalance;
  final List<ScheduleEntry> schedules;

  CreateScheduledOrderRequest({
    required this.productVsid,
    required this.bottlesPerDelivery,
    required this.weeklyFrequency,
    required this.notifyOnLowBalance,
    required this.schedules,
  });

  Map<String, dynamic> toJson() {
    return {
      'productVsid': productVsid,
      'bottlesPerDelivery': bottlesPerDelivery,
      'weeklyFrequency': weeklyFrequency,
      'notifyOnLowBalance': notifyOnLowBalance,
      'schedules': schedules.map((s) => s.toJson()).toList(),
    };
  }
}
```

### Step 2: Create Remote Data Source (1 hour)

**File:** `lib/features/scheduled_orders/data/datasources/scheduled_order_remote_datasource.dart`

```dart
abstract class ScheduledOrderRemoteDataSource {
  Future<ScheduledOrderModel> createScheduledOrder(CreateScheduledOrderRequest request);
  Future<List<ScheduledOrderModel>> getScheduledOrders({int? pageNumber, int? pageSize});
  Future<ScheduledOrderModel> getScheduledOrderById(int id);
  Future<void> rescheduleNextDelivery(int id, DateTime newDate);
  // Phase 2 (wait for backend)
  // Future<ScheduledOrderModel> updateScheduledOrder(int id, UpdateScheduledOrderRequest request);
  // Future<void> deleteScheduledOrder(int id);
}

class ScheduledOrderRemoteDataSourceImpl implements ScheduledOrderRemoteDataSource {
  final Dio dio;
  final AuthService authService;

  ScheduledOrderRemoteDataSourceImpl({
    required this.dio,
    required this.authService,
  });

  @override
  Future<ScheduledOrderModel> createScheduledOrder(
    CreateScheduledOrderRequest request,
  ) async {
    try {
      final token = await authService.getAccessToken();
      
      final response = await dio.post(
        '/v1/client/scheduled-orders',
        data: request.toJson(),
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'Content-Type': 'application/json',
          },
        ),
      );

      if (response.statusCode == 201) {
        return ScheduledOrderModel.fromJson(response.data);
      } else {
        throw ServerException(
          message: 'Failed to create scheduled order',
          code: 'CREATE_FAILED',
        );
      }
    } on DioException catch (e) {
      if (e.response?.statusCode == 400) {
        throw ValidationException(
          message: e.response?.data['error']?['message'] ?? 'Validation failed',
          details: e.response?.data['error']?['details'] ?? [],
        );
      } else if (e.response?.statusCode == 409) {
        throw ConflictException('Schedule already exists for this product');
      }
      throw ServerException(message: e.message ?? 'Network error');
    }
  }

  @override
  Future<List<ScheduledOrderModel>> getScheduledOrders({
    int? pageNumber,
    int? pageSize,
  }) async {
    try {
      final token = await authService.getAccessToken();
      
      final queryParams = <String, dynamic>{};
      if (pageNumber != null) queryParams['pageNumber'] = pageNumber;
      if (pageSize != null) queryParams['pageSize'] = pageSize;

      final response = await dio.get(
        '/v1/client/scheduled-orders',
        queryParameters: queryParams,
        options: Options(
          headers: {'Authorization': 'Bearer $token'},
        ),
      );

      if (response.statusCode == 200) {
        final items = response.data['items'] as List<dynamic>;
        return items
            .map((item) => ScheduledOrderModel.fromJson(item as Map<String, dynamic>))
            .toList();
      } else {
        throw ServerException(message: 'Failed to fetch scheduled orders');
      }
    } on DioException catch (e) {
      throw ServerException(message: e.message ?? 'Network error');
    }
  }

  @override
  Future<void> rescheduleNextDelivery(int id, DateTime newDate) async {
    try {
      final token = await authService.getAccessToken();
      
      final response = await dio.post(
        '/v1/client/scheduled-orders/$id/reschedule',
        data: {
          'newDate': newDate.toIso8601String(),
        },
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'Content-Type': 'application/json',
          },
        ),
      );

      if (response.statusCode != 200 && response.statusCode != 202) {
        throw ServerException(message: 'Failed to reschedule delivery');
      }
    } on DioException catch (e) {
      if (e.response?.statusCode == 400) {
        throw ValidationException(
          message: e.response?.data['error']?['message'] ?? 'Invalid date',
        );
      }
      throw ServerException(message: e.message ?? 'Network error');
    }
  }
}
```

### Step 3: Create Scheduled Order Screen (3 hours)

**File:** `lib/features/scheduled_orders/presentation/screens/create_scheduled_order_screen.dart`

```dart
class CreateScheduledOrderScreen extends StatefulWidget {
  final ProductModel product;

  const CreateScheduledOrderScreen({required this.product});

  @override
  _CreateScheduledOrderScreenState createState() => _CreateScheduledOrderScreenState();
}

class _CreateScheduledOrderScreenState extends State<CreateScheduledOrderScreen> {
  final _formKey = GlobalKey<FormState>();
  
  int _bottlesPerDelivery = 1;
  int _weeklyFrequency = 1;
  bool _notifyOnLowBalance = true;
  
  final Map<int, int> _selectedDayTimeSlots = {}; // dayOfWeek -> timeSlotId

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Create Delivery Schedule'),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Product Info Card
              _buildProductCard(),
              SizedBox(height: 24),
              
              // Bottles Per Delivery
              Text(
                'Bottles per Delivery',
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
              ),
              SizedBox(height: 8),
              Row(
                children: [
                  IconButton(
                    icon: Icon(Icons.remove_circle_outline),
                    onPressed: _bottlesPerDelivery > 1
                        ? () => setState(() => _bottlesPerDelivery--)
                        : null,
                  ),
                  Text(
                    '$_bottlesPerDelivery',
                    style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                  ),
                  IconButton(
                    icon: Icon(Icons.add_circle_outline),
                    onPressed: () => setState(() => _bottlesPerDelivery++),
                  ),
                ],
              ),
              SizedBox(height: 24),
              
              // Weekly Frequency
              Text(
                'Deliveries per Week',
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
              ),
              SizedBox(height: 8),
              Slider(
                value: _weeklyFrequency.toDouble(),
                min: 1,
                max: 7,
                divisions: 6,
                label: '$_weeklyFrequency times per week',
                onChanged: (value) {
                  setState(() {
                    _weeklyFrequency = value.toInt();
                    // Clear selections if frequency decreased
                    if (_selectedDayTimeSlots.length > _weeklyFrequency) {
                      _selectedDayTimeSlots.clear();
                    }
                  });
                },
              ),
              Text(
                '$_weeklyFrequency times per week',
                style: TextStyle(color: Colors.grey),
              ),
              SizedBox(height: 24),
              
              // Day and Time Selection
              Text(
                'Select Delivery Days & Times',
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
              ),
              SizedBox(height: 8),
              Text(
                'Select $_weeklyFrequency day(s)',
                style: TextStyle(color: Colors.grey, fontSize: 14),
              ),
              SizedBox(height: 16),
              
              _buildDayTimeSelector(),
              
              SizedBox(height: 24),
              
              // Notify on Low Balance
              SwitchListTile(
                title: Text('Notify when balance is low'),
                subtitle: Text('Get notified to refill your wallet'),
                value: _notifyOnLowBalance,
                onChanged: (value) => setState(() => _notifyOnLowBalance = value),
              ),
              
              SizedBox(height: 32),
              
              // Create Button
              SizedBox(
                width: double.infinity,
                height: 48,
                child: ElevatedButton(
                  onPressed: _createSchedule,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primary,
                  ),
                  child: Text(
                    'Create Schedule',
                    style: TextStyle(color: Colors.white, fontSize: 16),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildProductCard() {
    return Card(
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Row(
          children: [
            if (widget.product.primaryImage != null)
              CachedNetworkImage(
                imageUrl: widget.product.primaryImage!.filePath,
                width: 60,
                height: 60,
                fit: BoxFit.cover,
              ),
            SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.product.enName,
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  Text(
                    '${widget.product.price.toStringAsFixed(2)} QAR',
                    style: TextStyle(color: AppColors.primary),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDayTimeSelector() {
    final days = [
      'Sunday',
      'Monday',
      'Tuesday',
      'Wednesday',
      'Thursday',
      'Friday',
      'Saturday',
    ];

    return Column(
      children: List.generate(7, (dayIndex) {
        final isSelected = _selectedDayTimeSlots.containsKey(dayIndex);
        final canSelect = !isSelected && _selectedDayTimeSlots.length < _weeklyFrequency;

        return Card(
          margin: EdgeInsets.only(bottom: 12),
          color: isSelected ? AppColors.primary.withOpacity(0.1) : null,
          child: ExpansionTile(
            title: Text(
              days[dayIndex],
              style: TextStyle(
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
            subtitle: isSelected
                ? Text(
                    TimeSlots.getLocalizedName(_selectedDayTimeSlots[dayIndex]!),
                    style: TextStyle(color: AppColors.primary),
                  )
                : null,
            trailing: isSelected
                ? IconButton(
                    icon: Icon(Icons.close, color: Colors.red),
                    onPressed: () {
                      setState(() => _selectedDayTimeSlots.remove(dayIndex));
                    },
                  )
                : null,
            children: isSelected || canSelect
                ? TimeSlots.all.map((slot) {
                    final isSlotSelected = _selectedDayTimeSlots[dayIndex] == slot.id;
                    return RadioListTile<int>(
                      title: Text(slot.localizedName),
                      subtitle: Text(slot.displayTime),
                      value: slot.id,
                      groupValue: _selectedDayTimeSlots[dayIndex],
                      onChanged: (value) {
                        setState(() {
                          _selectedDayTimeSlots[dayIndex] = value!;
                        });
                      },
                    );
                  }).toList()
                : [
                    Padding(
                      padding: EdgeInsets.all(16),
                      child: Text(
                        'Maximum days selected',
                        style: TextStyle(color: Colors.grey),
                      ),
                    ),
                  ],
          ),
        );
      }),
    );
  }

  void _createSchedule() {
    if (_selectedDayTimeSlots.length != _weeklyFrequency) {
      Get.snackbar(
        'Error',
        'Please select $_weeklyFrequency delivery day(s)',
        backgroundColor: Colors.red,
        colorText: Colors.white,
      );
      return;
    }

    final schedules = _selectedDayTimeSlots.entries.map((entry) {
      return ScheduleEntry(
        dayOfWeek: entry.key,
        timeSlotId: entry.value,
      );
    }).toList();

    final request = CreateScheduledOrderRequest(
      productVsid: widget.product.vsid,
      bottlesPerDelivery: _bottlesPerDelivery,
      weeklyFrequency: _weeklyFrequency,
      notifyOnLowBalance: _notifyOnLowBalance,
      schedules: schedules,
    );

    // Call controller to create
    Get.find<ScheduledOrderController>().createScheduledOrder(request);
  }
}
```

---

## üîÑ PHASE 2: UPDATE & DELETE (Wait 3 Days)

### UPDATE Endpoint (After Confirmation)

**Endpoint:** `PUT /api/v1/client/scheduled-orders/{id}`

**Request:**
```json
{
  "bottlesPerDelivery": 3,
  "weeklyFrequency": 3,
  "schedules": [
    {"dayOfWeek": 0, "timeSlotId": 1},
    {"dayOfWeek": 2, "timeSlotId": 3},
    {"dayOfWeek": 4, "timeSlotId": 5}
  ]
}
```

**Cannot change:** `productVsid` (must cancel and recreate)

### DELETE Endpoint (After Confirmation)

**Endpoint:** `DELETE /api/v1/client/scheduled-orders/{id}`

**Behavior:**
- Soft delete (sets `isActive = false`)
- Unused coupons remain in wallet
- Cannot reactivate (must create new schedule)

---

## ‚úÖ ACCEPTANCE CRITERIA

### Phase 1 Complete When:
- [ ] Time slots constants file created
- [ ] Can create new scheduled order
- [ ] Validation prevents invalid schedules
- [ ] Scheduled orders list displays correctly
- [ ] Next delivery date shown
- [ ] Remaining coupons displayed
- [ ] Can request reschedule for next delivery
- [ ] "Pending Approval" status shown
- [ ] Low balance warning shown

### Phase 2 Complete When:
- [ ] Can edit schedule (bottles, frequency, days)
- [ ] Can cancel/delete schedule
- [ ] Confirmation dialog shown before delete
- [ ] All validation rules enforced
- [ ] Full integration testing passed

---

**END OF M1.0.3 GUIDE**
