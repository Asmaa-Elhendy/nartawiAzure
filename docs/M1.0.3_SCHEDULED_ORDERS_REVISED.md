# M1.0.3 - Scheduled Orders API Integration (REVISED)

**Release:** M1.0.3 - Scheduled Orders (Full CRUD)  
**Status:** üü° Partial Ready (CREATE/READ/RESCHEDULE ready, UPDATE/DELETE in 3 days)  
**Duration:** 2 weeks  
**Start:** +3 days from M1.0.2 completion  
**Target:** February 6, 2026

---

## ‚ö†Ô∏è CRITICAL CHANGES FROM ORIGINAL

**‚úÖ NO NEW SCREENS CREATED**  
All APIs integrate into **existing coupons UI**:
- `lib/features/coupons/presentation/screens/coupons_screen.dart`
- `lib/features/coupons/presentation/widgets/coupon_card.dart`
- `lib/features/coupons/presentation/widgets/refill_outline_button.dart`
- `lib/features/coupons/presentation/widgets/calender_dialog.dart`

---

## üìã EXISTING UI MAPPING TO SCHEDULED ORDER APIS

### Current UI Controls ‚Üí API Fields

| Existing UI Control | Current Behavior | Maps to API Field |
|---------------------|------------------|-------------------|
| Weekly Delivery Frequency (spinner) | Mock data | `weeklyFrequency` |
| Bottles Per Delivery (spinner) | Mock data | `bottlesPerDelivery` |
| Preferred Days Grid (7 day buttons) | Local state only | `schedules[].dayOfWeek` |
| Time slot (hardcoded "Before Noon") | Hardcoded | `schedules[].timeSlotId` |
| Next Refill button + calendar | Local state | Reschedule API |
| Auto-Renewal toggle | Local state | `notifyOnLowBalance` |

---

## üö® BACKEND BLOCKER STATUS

**UPDATE and DELETE endpoints in testing** - Ready January 12, 2026

### Phase 1 (START IMMEDIATELY): CREATE, READ, RESCHEDULE
- ‚úÖ `POST /v1/client/scheduled-orders` - CREATE
- ‚úÖ `GET /v1/client/scheduled-orders` - READ/LIST
- ‚úÖ `POST /v1/client/scheduled-orders/{id}/reschedule` - RESCHEDULE

### Phase 2 (WAIT 3 DAYS): UPDATE, DELETE
- ‚è∏Ô∏è `PUT /v1/client/scheduled-orders/{id}` - UPDATE
- ‚è∏Ô∏è `DELETE /v1/client/scheduled-orders/{id}` - DELETE

---

## üìÖ PHASE 1 IMPLEMENTATION (Days 1-5)

### Step 1: Create Time Slots Constants (15 mins)

**New File:** `lib/core/constants/time_slots.dart`

```dart
class TimeSlot {
  final int id;
  final String nameEn;
  final String nameAr;
  final String startTime;
  final String endTime;
  final String displayTime;

  const TimeSlot({
    required this.id,
    required this.nameEn,
    required this.nameAr,
    required this.startTime,
    required this.endTime,
    required this.displayTime,
  });

  String get localizedName {
    final locale = Get.locale?.languageCode ?? 'en';
    return locale == 'ar' ? nameAr : nameEn;
  }
}

class TimeSlots {
  static const List<TimeSlot> all = [
    TimeSlot(
      id: 1,
      nameEn: 'Early Morning',
      nameAr: 'ÿßŸÑÿµÿ®ÿßÿ≠ ÿßŸÑÿ®ÿßŸÉÿ±',
      startTime: '06:00:00',
      endTime: '09:00:00',
      displayTime: '6:00 AM - 9:00 AM',
    ),
    TimeSlot(
      id: 2,
      nameEn: 'Before Noon',
      nameAr: 'ŸÇÿ®ŸÑ ÿßŸÑÿ∏Ÿáÿ±',
      startTime: '10:00:00',
      endTime: '13:00:00',
      displayTime: '10:00 AM - 1:00 PM',
    ),
    TimeSlot(
      id: 3,
      nameEn: 'Afternoon',
      nameAr: 'ÿ®ÿπÿØ ÿßŸÑÿ∏Ÿáÿ±',
      startTime: '13:00:00',
      endTime: '17:00:00',
      displayTime: '1:00 PM - 5:00 PM',
    ),
    TimeSlot(
      id: 4,
      nameEn: 'Evening',
      nameAr: 'ÿßŸÑŸÖÿ≥ÿßÿ°',
      startTime: '17:00:00',
      endTime: '21:00:00',
      displayTime: '5:00 PM - 9:00 PM',
    ),
    TimeSlot(
      id: 5,
      nameEn: 'Night',
      nameAr: 'ÿßŸÑŸÑŸäŸÑ',
      startTime: '20:00:00',
      endTime: '23:59:00',
      displayTime: '8:00 PM - 11:59 PM',
    ),
  ];

  static TimeSlot? getById(int id) {
    try {
      return all.firstWhere((slot) => slot.id == id);
    } catch (e) {
      return null;
    }
  }

  static String getDisplayTime(int id) {
    final slot = getById(id);
    return slot?.displayTime ?? 'Unknown';
  }
}
```

---

### Step 2: Create Scheduled Order Models (1 hour)

**New File:** `lib/features/coupons/data/models/scheduled_order_model.dart`

```dart
class ScheduleEntry {
  final int dayOfWeek; // 0=Sunday, 1=Monday, ..., 6=Saturday
  final String? dayName;
  final int timeSlotId;
  final String? timeSlotName;

  ScheduleEntry({
    required this.dayOfWeek,
    this.dayName,
    required this.timeSlotId,
    this.timeSlotName,
  });

  Map<String, dynamic> toJson() {
    return {
      'dayOfWeek': dayOfWeek,
      'timeSlotId': timeSlotId,
    };
  }

  factory ScheduleEntry.fromJson(Map<String, dynamic> json) {
    return ScheduleEntry(
      dayOfWeek: json['dayOfWeek'] as int,
      dayName: json['dayName'] as String?,
      timeSlotId: json['timeSlotId'] as int,
      timeSlotName: json['timeSlotName'] as String?,
    );
  }
}

class ScheduledOrderModel {
  final int id;
  final String scheduleNumber;
  final int productVsid;
  final String productName;
  final int bottlesPerDelivery;
  final int weeklyFrequency;
  final bool isActive;
  final bool isPaused;
  final int statusId;
  final String statusName;
  final bool notifyOnLowBalance;
  final DateTime? nextRun;
  final int remainingCoupons;
  final int estimatedRunsRemaining;
  final List<ScheduleEntry> schedules;
  final DateTime createdAt;

  ScheduledOrderModel({
    required this.id,
    required this.scheduleNumber,
    required this.productVsid,
    required this.productName,
    required this.bottlesPerDelivery,
    required this.weeklyFrequency,
    required this.isActive,
    required this.isPaused,
    required this.statusId,
    required this.statusName,
    required this.notifyOnLowBalance,
    this.nextRun,
    required this.remainingCoupons,
    required this.estimatedRunsRemaining,
    required this.schedules,
    required this.createdAt,
  });

  factory ScheduledOrderModel.fromJson(Map<String, dynamic> json) {
    return ScheduledOrderModel(
      id: json['id'] as int,
      scheduleNumber: json['scheduleNumber'] as String,
      productVsid: json['productVsid'] as int,
      productName: json['productName'] as String,
      bottlesPerDelivery: json['bottlesPerDelivery'] as int,
      weeklyFrequency: json['weeklyFrequency'] as int,
      isActive: json['isActive'] as bool,
      isPaused: json['isPaused'] as bool,
      statusId: json['statusId'] as int,
      statusName: json['statusName'] as String,
      notifyOnLowBalance: json['notifyOnLowBalance'] as bool,
      nextRun: json['nextRun'] != null 
          ? DateTime.parse(json['nextRun'] as String) 
          : null,
      remainingCoupons: json['remainingCoupons'] as int,
      estimatedRunsRemaining: json['estimatedRunsRemaining'] as int,
      schedules: (json['schedules'] as List<dynamic>)
          .map((e) => ScheduleEntry.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdAt: DateTime.parse(json['createdAt'] as String),
    );
  }
}

class CreateScheduledOrderRequest {
  final int productVsid;
  final int bottlesPerDelivery;
  final int weeklyFrequency;
  final bool notifyOnLowBalance;
  final List<ScheduleEntry> schedules;

  CreateScheduledOrderRequest({
    required this.productVsid,
    required this.bottlesPerDelivery,
    required this.weeklyFrequency,
    required this.notifyOnLowBalance,
    required this.schedules,
  });

  Map<String, dynamic> toJson() {
    return {
      'productVsid': productVsid,
      'bottlesPerDelivery': bottlesPerDelivery,
      'weeklyFrequency': weeklyFrequency,
      'notifyOnLowBalance': notifyOnLowBalance,
      'schedules': schedules.map((s) => s.toJson()).toList(),
    };
  }
}
```

---

### Step 3: Create Scheduled Order Remote Data Source (1 hour)

**New File:** `lib/features/coupons/data/datasources/scheduled_order_remote_datasource.dart`

```dart
import 'package:dio/dio.dart';
import '../models/scheduled_order_model.dart';
import '../../../../core/services/auth_service.dart';

abstract class ScheduledOrderRemoteDataSource {
  Future<ScheduledOrderModel> createScheduledOrder(CreateScheduledOrderRequest request);
  Future<List<ScheduledOrderModel>> getScheduledOrders({int? pageNumber, int? pageSize});
  Future<void> rescheduleNextDelivery(int id, DateTime newDate);
}

class ScheduledOrderRemoteDataSourceImpl implements ScheduledOrderRemoteDataSource {
  final Dio dio;
  static const String baseUrl = 'https://nartawi.smartvillageqatar.com/api';

  ScheduledOrderRemoteDataSourceImpl({required this.dio});

  @override
  Future<ScheduledOrderModel> createScheduledOrder(
    CreateScheduledOrderRequest request,
  ) async {
    try {
      final token = await AuthService.getToken();
      
      final response = await dio.post(
        '$baseUrl/v1/client/scheduled-orders',
        data: request.toJson(),
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'Content-Type': 'application/json',
          },
        ),
      );

      if (response.statusCode == 201) {
        return ScheduledOrderModel.fromJson(response.data);
      } else {
        throw Exception('Failed to create scheduled order');
      }
    } on DioException catch (e) {
      throw Exception(e.response?.data?['error']?['message'] ?? 'Failed to create schedule');
    }
  }

  @override
  Future<List<ScheduledOrderModel>> getScheduledOrders({
    int? pageNumber,
    int? pageSize,
  }) async {
    try {
      final token = await AuthService.getToken();
      
      final queryParams = <String, dynamic>{};
      if (pageNumber != null) queryParams['pageNumber'] = pageNumber;
      if (pageSize != null) queryParams['pageSize'] = pageSize;

      final response = await dio.get(
        '$baseUrl/v1/client/scheduled-orders',
        queryParameters: queryParams,
        options: Options(
          headers: {'Authorization': 'Bearer $token'},
        ),
      );

      if (response.statusCode == 200) {
        final items = response.data['items'] as List<dynamic>;
        return items
            .map((item) => ScheduledOrderModel.fromJson(item as Map<String, dynamic>))
            .toList();
      } else {
        throw Exception('Failed to fetch scheduled orders');
      }
    } on DioException catch (e) {
      throw Exception(e.response?.data?['error']?['message'] ?? 'Network error');
    }
  }

  @override
  Future<void> rescheduleNextDelivery(int id, DateTime newDate) async {
    try {
      final token = await AuthService.getToken();
      
      final response = await dio.post(
        '$baseUrl/v1/client/scheduled-orders/$id/reschedule',
        data: {
          'newDate': newDate.toIso8601String(),
        },
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'Content-Type': 'application/json',
          },
        ),
      );

      if (response.statusCode != 200 && response.statusCode != 202) {
        throw Exception('Failed to reschedule delivery');
      }
    } on DioException catch (e) {
      throw Exception(e.response?.data?['error']?['message'] ?? 'Failed to reschedule');
    }
  }
}
```

---

### Step 4: Update CouponController to Include Scheduled Orders (2 hours)

**File:** `lib/features/coupons/presentation/provider/coupon_controller.dart`

**Add these methods to existing controller:**

```dart
// Add these imports
import '../data/datasources/scheduled_order_remote_datasource.dart';
import '../data/models/scheduled_order_model.dart';

// Add these properties
late final ScheduledOrderRemoteDataSource _scheduledOrderDataSource;
List<ScheduledOrderModel> _scheduledOrders = [];
bool _isLoadingSchedules = false;
String? _schedulesError;

// Add getter
List<ScheduledOrderModel> get scheduledOrders => _scheduledOrders;
bool get isLoadingSchedules => _isLoadingSchedules;
String? get schedulesError => _schedulesError;

// Initialize in constructor
CouponsController({required Dio dio}) {
  _dio = dio;
  _scheduledOrderDataSource = ScheduledOrderRemoteDataSourceImpl(dio: dio);
}

// Add these methods
Future<void> fetchScheduledOrders() async {
  _isLoadingSchedules = true;
  _schedulesError = null;
  notifyListeners();

  try {
    _scheduledOrders = await _scheduledOrderDataSource.getScheduledOrders();
  } catch (e) {
    _schedulesError = e.toString();
  } finally {
    _isLoadingSchedules = false;
    notifyListeners();
  }
}

Future<ScheduledOrderModel?> createScheduledOrder({
  required int bundlePurchaseId,
  required int productVsid,
  required int bottlesPerDelivery,
  required int weeklyFrequency,
  required bool notifyOnLowBalance,
  required List<ScheduleEntry> schedules,
}) async {
  try {
    final request = CreateScheduledOrderRequest(
      productVsid: productVsid,
      bottlesPerDelivery: bottlesPerDelivery,
      weeklyFrequency: weeklyFrequency,
      notifyOnLowBalance: notifyOnLowBalance,
      schedules: schedules,
    );

    final created = await _scheduledOrderDataSource.createScheduledOrder(request);
    
    // Refresh list
    await fetchScheduledOrders();
    
    return created;
  } catch (e) {
    _schedulesError = e.toString();
    notifyListeners();
    return null;
  }
}

Future<bool> rescheduleNextDelivery(int scheduleId, DateTime newDate) async {
  try {
    await _scheduledOrderDataSource.rescheduleNextDelivery(scheduleId, newDate);
    
    // Refresh list
    await fetchScheduledOrders();
    
    return true;
  } catch (e) {
    _schedulesError = e.toString();
    notifyListeners();
    return false;
  }
}

// Helper to get schedule for a bundle
ScheduledOrderModel? getScheduleForBundle(int bundlePurchaseId) {
  // You'll need to track bundlePurchaseId -> scheduleId mapping
  // For now, return first active schedule
  try {
    return _scheduledOrders.firstWhere((s) => s.isActive);
  } catch (e) {
    return null;
  }
}
```

---

### Step 5: Update coupon_card.dart to Call APIs (3 hours)

**File:** `lib/features/coupons/presentation/widgets/coupon_card.dart`

**Key Changes:**

1. **Load existing schedule on init:**
```dart
@override
void initState() {
  super.initState();
  
  // Load existing schedule for this bundle
  _loadScheduleData();
  
  // ... existing init code
}

Future<void> _loadScheduleData() async {
  // Get schedule from controller
  final controller = context.read<CouponsController>(); // or Get.find
  final schedule = controller.getScheduleForBundle(widget.bundle.id);
  
  if (schedule != null) {
    setState(() {
      _quantityController.text = schedule.weeklyFrequency.toString();
      _quantityTwoController.text = schedule.bottlesPerDelivery.toString();
      _isSwitched = schedule.notifyOnLowBalance;
      
      // Set selected days from schedule
      _selectedPreferredDays.clear();
      for (var entry in schedule.schedules) {
        _selectedPreferredDays.add(entry.dayOfWeek);
      }
    });
  }
}
```

2. **Add "Save Schedule" button at bottom of card:**
```dart
// After NextRefillButton widget
ElevatedButton(
  onPressed: _saveSchedule,
  style: ElevatedButton.styleFrom(
    backgroundColor: AppColors.primary,
    minimumSize: Size(double.infinity, screenHeight * .06),
  ),
  child: Text(
    'Save Schedule',
    style: TextStyle(
      color: Colors.white,
      fontSize: screenWidth * .04,
      fontWeight: FontWeight.w600,
    ),
  ),
),
```

3. **Implement save method:**
```dart
Future<void> _saveSchedule() async {
  // Validation
  final weeklyFreq = int.tryParse(_quantityController.text) ?? 0;
  final bottlesPerDelivery = int.tryParse(_quantityTwoController.text) ?? 0;
  
  if (weeklyFreq <= 0 || weeklyFreq > 7) {
    // Show error
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Weekly frequency must be 1-7')),
    );
    return;
  }
  
  if (_selectedPreferredDays.length != weeklyFreq) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Select $weeklyFreq preferred day(s)')),
    );
    return;
  }
  
  // Build schedules array
  final schedules = _selectedPreferredDays.map((dayIndex) {
    return ScheduleEntry(
      dayOfWeek: dayIndex,
      timeSlotId: 2, // Default "Before Noon" - can make this selectable
    );
  }).toList();
  
  // Call API
  final controller = context.read<CouponsController>(); // or Get.find
  final result = await controller.createScheduledOrder(
    bundlePurchaseId: widget.bundle.id,
    productVsid: widget.bundle.productVsid, // You'll need this field
    bottlesPerDelivery: bottlesPerDelivery,
    weeklyFrequency: weeklyFreq,
    notifyOnLowBalance: _isSwitched,
    schedules: schedules,
  );
  
  if (result != null) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Schedule saved! Pending vendor approval.'),
        backgroundColor: Colors.green,
      ),
    );
  } else {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(controller.schedulesError ?? 'Failed to save schedule'),
        backgroundColor: Colors.red,
      ),
    );
  }
}
```

---

### Step 6: Update NextRefillButton to Call Reschedule API (1 hour)

**File:** `lib/features/coupons/presentation/widgets/refill_outline_button.dart`

**Update onTap callback:**

```dart
onTap: () async {
  final newDate = await showDialog<DateTime?>(
    context: context,
    builder: (context) => NextRefillCalendarDialog(
      selectedDays: widget.selectedDays,
      remainingRefills: widget.remainingRefills ?? 10,
      nextRefillDate: _currentFirstRefillDate,
    ),
  );

  if (newDate != null) {
    // Call reschedule API
    final controller = context.read<CouponsController>(); // or Get.find
    final schedule = controller.getScheduleForBundle(widget.bundlePurchaseId);
    
    if (schedule != null) {
      final success = await controller.rescheduleNextDelivery(
        schedule.id,
        newDate,
      );
      
      if (success) {
        setState(() {
          _currentFirstRefillDate = newDate;
        });
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Next delivery rescheduled'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to reschedule'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
},
```

**Update widget constructor to accept bundle ID:**
```dart
final int? bundlePurchaseId;
final int? remainingRefills;

const NextRefillButton({
  Key? key,
  required this.selectedDays,
  this.bundlePurchaseId,
  this.remainingRefills,
}) : super(key: key);
```

---

### Step 7: Add Time Slot Selection (Optional Enhancement - 1 hour)

Currently hardcoded to "Before Noon" (timeSlotId: 2). To make it selectable:

**Add dropdown in coupon_card.dart after "Preferred Refill Times /Week":**

```dart
// Add state variable
int _selectedTimeSlotId = 2; // Default Before Noon

// Add dropdown
DropdownButtonFormField<int>(
  value: _selectedTimeSlotId,
  decoration: InputDecoration(
    labelText: 'Preferred Time Slot',
    border: OutlineInputBorder(),
  ),
  items: TimeSlots.all.map((slot) {
    return DropdownMenuItem(
      value: slot.id,
      child: Text(slot.localizedName),
    );
  }).toList(),
  onChanged: (value) {
    setState(() => _selectedTimeSlotId = value ?? 2);
  },
),
```

Then update schedule creation to use `_selectedTimeSlotId` instead of hardcoded `2`.

---

## üß™ PHASE 1 TESTING

### Test Case 1: Create Schedule
1. Open coupons screen
2. Select a bundle card
3. Set weekly frequency (e.g., 2 days)
4. Set bottles per delivery (e.g., 3)
5. Select 2 preferred days
6. Enable auto-renewal toggle
7. Click "Save Schedule"
8. Verify success message "Pending vendor approval"
9. Check API logs: `POST /v1/client/scheduled-orders`
10. Verify schedule appears with statusId: 1 (Pending Approval)

### Test Case 2: View Existing Schedules
1. Fetch schedules on screen load
2. Verify UI populates with existing data:
   - Weekly frequency matches
   - Bottles per delivery matches
   - Selected days highlight correctly
   - Auto-renewal toggle matches

### Test Case 3: Reschedule Next Delivery
1. Click "Next Refill" button
2. Calendar opens with available dates
3. Select a new date
4. Click confirm
5. Verify API call: `POST /v1/client/scheduled-orders/{id}/reschedule`
6. Verify success message
7. Verify next refill date updates

### Test Case 4: Validation Errors
1. Try to save with 0 weekly frequency ‚Üí Error shown
2. Try to save with frequency 3 but only 2 days selected ‚Üí Error shown
3. Try to save with 8 days frequency ‚Üí Error shown

---

## ‚è≥ PHASE 2 IMPLEMENTATION (Days 6-10)

**WAIT for backend confirmation before starting!**

### Step 8: Add UPDATE Endpoint (After January 12)

**Add to ScheduledOrderRemoteDataSource:**

```dart
Future<ScheduledOrderModel> updateScheduledOrder(
  int id,
  UpdateScheduledOrderRequest request,
) async {
  try {
    final token = await AuthService.getToken();
    
    final response = await dio.put(
      '$baseUrl/v1/client/scheduled-orders/$id',
      data: request.toJson(),
      options: Options(
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
      ),
    );

    if (response.statusCode == 200) {
      return ScheduledOrderModel.fromJson(response.data);
    } else {
      throw Exception('Failed to update schedule');
    }
  } on DioException catch (e) {
    throw Exception(e.response?.data?['error']?['message'] ?? 'Update failed');
  }
}
```

**Update "Save Schedule" to use PUT for existing schedules:**

```dart
Future<void> _saveSchedule() async {
  // ... validation code ...
  
  final controller = context.read<CouponsController>();
  final existingSchedule = controller.getScheduleForBundle(widget.bundle.id);
  
  if (existingSchedule != null) {
    // UPDATE existing
    final result = await controller.updateScheduledOrder(
      existingSchedule.id,
      bottlesPerDelivery: bottlesPerDelivery,
      weeklyFrequency: weeklyFreq,
      schedules: schedules,
    );
  } else {
    // CREATE new
    final result = await controller.createScheduledOrder(/* ... */);
  }
}
```

### Step 9: Add DELETE Endpoint (After January 12)

**Add to ScheduledOrderRemoteDataSource:**

```dart
Future<void> deleteScheduledOrder(int id) async {
  try {
    final token = await AuthService.getToken();
    
    final response = await dio.delete(
      '$baseUrl/v1/client/scheduled-orders/$id',
      options: Options(
        headers: {'Authorization': 'Bearer $token'},
      ),
    );

    if (response.statusCode != 200 && response.statusCode != 204) {
      throw Exception('Failed to delete schedule');
    }
  } on DioException catch (e) {
    throw Exception(e.response?.data?['error']?['message'] ?? 'Delete failed');
  }
}
```

**Add "Cancel Schedule" button in coupon_card.dart:**

```dart
if (existingSchedule != null)
  OutlinedButton(
    onPressed: () => _cancelSchedule(existingSchedule.id),
    style: OutlinedButton.styleFrom(
      foregroundColor: Colors.red,
      side: BorderSide(color: Colors.red),
      minimumSize: Size(double.infinity, screenHeight * .06),
    ),
    child: Text('Cancel Schedule'),
  ),
```

```dart
Future<void> _cancelSchedule(int scheduleId) async {
  final confirm = await showDialog<bool>(
    context: context,
    builder: (context) => AlertDialog(
      title: Text('Cancel Schedule?'),
      content: Text('Are you sure you want to cancel this scheduled delivery?'),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context, false),
          child: Text('No'),
        ),
        ElevatedButton(
          onPressed: () => Navigator.pop(context, true),
          style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
          child: Text('Yes, Cancel'),
        ),
      ],
    ),
  );

  if (confirm == true) {
    final controller = context.read<CouponsController>();
    final success = await controller.deleteScheduledOrder(scheduleId);
    
    if (success) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Schedule cancelled'), backgroundColor: Colors.green),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to cancel'), backgroundColor: Colors.red),
      );
    }
  }
}
```

---

## ‚úÖ ACCEPTANCE CRITERIA

### Phase 1 Complete When:
- [ ] Time slots constants file created
- [ ] Scheduled order models created
- [ ] Remote data source with CREATE/READ/RESCHEDULE implemented
- [ ] CouponController extended with schedule methods
- [ ] coupon_card.dart calls CREATE API on "Save Schedule"
- [ ] coupon_card.dart loads existing schedule data
- [ ] NextRefillButton calls RESCHEDULE API
- [ ] All validation rules enforced
- [ ] Success/error messages shown
- [ ] Network logs show correct API calls
- [ ] "Pending Approval" status displays

### Phase 2 Complete When (After January 12):
- [ ] UPDATE endpoint implemented
- [ ] DELETE endpoint implemented
- [ ] "Save Schedule" uses PUT for existing schedules
- [ ] "Cancel Schedule" button works
- [ ] Confirmation dialog before delete
- [ ] All Phase 2 tests passed

---

## üö® CRITICAL NOTES

1. **NO UI Changes**
   - All APIs integrate into existing widgets
   - No new screens created
   - Only backend connectivity added

2. **Hardcoded vs API Data**
   - Time slots: Hardcoded constants (no API)
   - Day/time selection: From UI state
   - Schedule status: From API response

3. **productVsid Field**
   - You may need to add `productVsid` to `BundlePurchase` model
   - Check if backend returns this in bundle purchase response
   - If not, you'll need to track it separately

4. **Schedule-to-Bundle Mapping**
   - Backend doesn't explicitly link scheduleId to bundlePurchaseId
   - You may need to:
     - Store mapping locally
     - Or filter schedules by productVsid
     - Or use schedule status/dates to match

5. **Auto-Renewal Behavior**
   - Toggle maps to `notifyOnLowBalance`
   - Does NOT auto-purchase bundles
   - Only sends notification when balance low

---

## üìù FILES MODIFIED SUMMARY

**New Files:**
- `lib/core/constants/time_slots.dart`
- `lib/features/coupons/data/models/scheduled_order_model.dart`
- `lib/features/coupons/data/datasources/scheduled_order_remote_datasource.dart`

**Modified Files:**
- `lib/features/coupons/presentation/provider/coupon_controller.dart` - Add schedule methods
- `lib/features/coupons/presentation/widgets/coupon_card.dart` - Add save/load logic
- `lib/features/coupons/presentation/widgets/refill_outline_button.dart` - Add reschedule API call

**NOT Modified:**
- `lib/features/coupons/presentation/screens/coupons_screen.dart` - No changes needed
- `lib/features/coupons/presentation/widgets/calender_dialog.dart` - Works as-is

---

**END OF M1.0.3 REVISED GUIDE**
